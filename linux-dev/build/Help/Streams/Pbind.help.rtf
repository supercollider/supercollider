{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red191\green0\blue0;\red0\green0\blue191;
\red0\green115\blue0;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Pbind
\f1\b0\fs24 \
\
\
The class 
\f0\b Pbind
\f1\b0  provides a bridge between value patterns and event patterns. It binds symbols in each event to values obtained from a pattern. Pbind takes arguments in pairs, the first of a pair being a Symbol and the second being a value Pattern. Remember that any object can act as a Pattern, so you can use constants as the pattern.\
\
The Pbind stream returns nil whenever the first one of its streams ends.\
\
An event stream is created for a Pattern by sending it the 
\f0\b asEventStream
\f1\b0  message. The 
\f0\b asEventStream
\f1\b0  message takes an Event as an argument. This event is copied for each call to 
\f0\b next
\f1\b0  to pass down and back up the tree of patterns so that each pattern can modify the event. What Pbind does is put the values for its symbols into the event, possibly overwriting previous bindings to those symbols.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\cf3 // the theory...\

\f2\fs18 \cf4 Instrument\cf2 (\cf5 \\sin\cf2 ,\{ \cf4 arg\cf2  out,freq,amp;\
	\cf4 Out\cf2 .ar(out,\
		\cf4 SinOsc\cf2 .ar(freq,0,amp)\
	)\
\});\
\
\cf3 // have to write the def still...\

\f1\fs24 \cf2 \
\cf3 // node def not found...\

\f2\fs18 \cf4 Pbind\cf2 (\
	\cf5 \\dur\cf2 ,1 ,\
	\cf5 \\instrument\cf2  , \cf5 \\sin\cf2 \
).play\
\

\f1\fs24 \cf0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 //
\f2 (
\fs18 \cf6 \
//var pattern, stream;\
//\
//	// bind Symbol xyz to values obtained from a pattern\
//pattern = Pbind( \
//		\\xyz, Pseq([1, 2, 3]) \
//	);\
//	\
//	// create an event Stream for the Pbind pattern.\
//	// event Streams require a prototype event as input.\
//	// this example uses an empty Event as a prototype\
//stream = pattern.asEventStream(Event.new);\
//\
//	// print the output events.\
//4.do(\{  stream.next.postln; \});\
//\
//
\fs24 \cf6 )\
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Here is an example with more bindings.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 //
\f2 (
\fs18 \cf6 \
//var pattern, stream;\
//\
//pattern = Pbind( \
//		\\abc, Prand([6, 7, 8, 9], 8), \
//		\\xyz, Pseq([1, 2, 3], 2),\
//		\\uuu, 999		// a constant represents an infinite sequence of itself\
//	);\
//	\
//stream = pattern.asEventStream(Event.new);\
//\
//7.do(\{  stream.next.postln; \});\
//
\fs24 \cf6 )\
\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 The ListPatterns discussed in part 3 can be put around Event Streams to create sequences of Event Streams.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 //
\f2 (
\fs18 \cf6 \
//var pattern, stream;\
//pattern = \
//	Pseq([\
//		Pbind( \\abc, Pseq([1, 2, 3])),\
//		Pbind( \\def, Pseq([4, 5, 6])),\
//		Pbind( \\xyz, Pseq([7, 8, 9]))\
//	]);	\
//stream = pattern.asEventStream(Event.new);\
//10.do(\{  stream.next.postln; \});\
//
\fs24 \cf6 )\
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf6 //
\f2 (\
//var pattern, stream;\
//pattern = \
//	Prand([\
//		Pbind( \\abc, Pseq([1, 2, 3])),\
//		Pbind( \\def, Pseq([4, 5, 6])),\
//		Pbind( \\xyz, Pseq([7, 8, 9]))\
//	], 3);\
//	\
//stream = pattern.asEventStream(Event.new);\
//10.do(\{  stream.next.postln; \});\
//)\
\cf0 \

\f0\b\fs28 Making Sound using an Event Stream\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
The following example uses a Pbind event stream to generate sound events. \
The events generated by the stream are made the current Environment via the 
\f0\b use
\f1\b0  message.\
Then the valueEnvir message is used to get the instrument's argument values from the current Environment.\
Which instrument to play is also a pattern bound to the Symbol \\instr.\
\

\f2\fs18 \cf6 //(\
//var a, b, c, pattern, stream;\
//\
//a = \{ arg freq, amp, pan;\
//	Pan2.ar(SinOsc.ar(freq), pan, amp);\
//\};\
//b =  \{ arg amp, pan, freq;\
//	Pan2.ar(RLPF.ar(Saw.ar(freq), freq * 6, 0.1), pan, amp);\
//\};\
//c =  \{ arg pan, freq, amp;\
//	Pan2.ar(Resonz.ar(GrayNoise.ar, freq * 4, 0.04), pan, amp * 8);\
//\};\
//\
//pattern = Pbind(\
//	\\freq, Pseq([100, 150, 200, 225, 250, 275, 300, 350, 400], inf),\
//	\\amp, 0.1,\
//	\\pan, Pfunc(\{ 1.0.rand2 \}),\
//	\\instr, Prand([ Pseq([a],3),  Pseq([b],3),  Pseq([c],3) ], inf)\
//);\
//\
//stream = pattern.asEventStream(Event.new);\
//\
//Synth.scope(\{\
//	var out;\
//	out = OverlapTexture.ar(\{\
//		var event;\
//		event = stream.next;\
//		event.use(\{\
//			~instr.valueEnvir;\
//		\});\
//	\}, 1, 0.2, 2, 2);\
//	CombN.ar(out, 0.2, 0.2, 3, 1, out);\
//\}, 0.04);\
//)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
\

\f0\b\fs28 UGens as Event values.\

\f2\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 The following example creates unit generators instead of scalar values for\
the values bound to the arguments. This shows that you can use patterns\
to dynamically build your patch. Score data is not limited to scalar values.\
This example can generate 36 different patches: 3 instruments * 3 freqs\
* 2 amps * 2 pans\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\cf6 //
\fs18 \cf6 (\
//var a, b, c, pattern, stream;\
//\
//a = \{ arg freq, amp, pan;\
//	Pan2.ar(SinOsc.ar(freq), pan, amp);\
//\};\
//b =  \{ arg amp, pan, freq;\
//	Pan2.ar(RLPF.ar(Saw.ar(freq), freq * 6, 0.1), pan, amp);\
//\};\
//c =  \{ arg pan, freq, amp;\
//	Pan2.ar(Resonz.ar(GrayNoise.ar, freq * 4, 0.04), pan, amp * 8);\
//\};\
//\
//pattern = Pbind(\
//	\\freq, \
//		Pfunc(\{\
//			// randomly choose a sweep, a vibrato, or an arpeggio\
//			[\
//				\{ XLine.kr(exprand(40, 2000), exprand(40, 2000), 2.2) \},\
//				\{ \
//					var f;\
//					f = 2000.0.rand;\
//					SinOsc.kr(20.0.linrand, 0, f * 0.5.linrand, f) \
//				\},\
//				\{ \
//					Sequencer.kr(\
//						`([ [0, 4, 7, 12], [12, 11, 10, 9] ].choose), \
//						Impulse.kr(8), \
//						1, \
//						48 + 36.rand\
//					).midicps \
//				\}\
//			].choose.value;\
//		\}),\
//	\\amp, Pfunc(\{  \
//			[\
//				\{ SinOsc.kr(20.0.rand, 0, 0.1, 0.1) \},\
//				\{ XLine.kr(exprand(0.002, 0.2), exprand(0.002, 0.2), 2.2) \} \
//			].choose.value;\
//		\}),\
//	\\pan, Pfunc(\{  \
//			[\
//				\{ Line.kr(1.0.rand2, 1.0.rand2, 2.2)  \},\
//				\{ SinOsc.kr(4.0.rand) \}\
//			].choose.value;\
//		\}),\
//	\\instr, Prand([ a, b, c ], inf)\
//);\
//\
//stream = pattern.asEventStream(Event.new);\
//\
//Synth.play(\{\
//	var out;\
//	out = OverlapTexture.ar(\{\
//		var event;\
//		event = stream.next;\
//		event.use(\{\
//			~instr.valueEnvir;\
//		\});\
//	\}, 2, 0.1, 2, 2);\
//	CombN.ar(out, 0.2, 0.2, 1, 0.7, out);\
//\});\
//)\
}