{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Oblique;
\f3\fswiss\fcharset77 Helvetica-BoldOblique;\f4\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green115\blue0;\red191\green0\blue0;\red0\green0\blue191;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SynthDef				
\fs30 definition of a synth architecture \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \
\
\
Evaluates a UGen function, generating a ugenGraph that describes the exact architecture of a Synth.  \
All constants, Controls, and UGens that will be used in synthesis are formatted for the Server and written to disk.  \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *new(synthDefName,ugenGraphFunc, rates, prependArgs)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 	Create a synthDef instance, evaluate the ugenGraphFunc and build the ugenGraph.\
\
	
\f0\b synthDefName\
			
\f1\b0 string or symbol: "name", 'name', or \\name\
			\
	
\f0\b ugenGraphFunc\
		\
		evaluation :\
			
\f1\b0 Functions inside of a SynthDef are evaluated 
\f2\i only at the time of building 
\f1\i0 \
			the ugenGraph.  Once the graph is built, it is a fixed architecture.\
		\
		
\f0\b arguments:
\f1\b0 \
			the arguments of the ugenGraphFunction are converted into instances of 
\f0\b Control\
			
\f1\b0 \
			arguments to the ugenGraphFunc that begin with "i_" will be 
\f0\b static
\f1\b0  and non-modulatable.\
			They will not respond to /n_set or /n_map.\
		\
			arguments to the ugenGraphFunc that begin with "t_" will be made as a 
\f0\b TrigControl
\f1\b0 . Setting \
			the argument will create a k-rate impulse at the set value. This is useful for triggers.\
		\
			other arguments are all Float inputs, representing 
\f0\b control rate values
\f1\b0  (integer indices \
			for use in In or Out are floats that are truncated to the integer value)\
			\
			there are two argument names that have a 
\f3\i\b common use
\f1\i0\b0  and thus are of significance:\
			(they do not have to be used, but it is often convenient to do so)\
			\
				
\f0\b out
\f1\b0 		the out bus index\
				
\f0\b gate
\f1\b0 		envelope gate, 
\f2\i which can free the synth
\f1\i0 .\
						if a gate arg is specified within an EnvGen with the 
\f0\b doneAction 2
\f1\b0  or larger,\
						the running synth object (which is not the SynthDef!) can be sent the\
						message 
\f0\b release
\f1\b0 . Also in Event Patterns like 
\f0\b Pbind
\f1\b0 , this scheme is used.\
						see also 
\f0\b EnvGen
\f1\b0  help\
	\
		\
		
\f0\b rates
\f1\b0  \
			An optional Array of specifications for the ugenGraphFunc's arguments. The order corresponds \
			to the order of arguments. See the examples below to see how these are used.\
			A specification can be:\
				
\f0\b nil/zero
\f1\b0 :	a standard control rate Control is created\
				
\f0\b a float
\f1\b0 	the Control will have a lag of the specified time. This can be used to create \
						smooth transitions between differnt values. t_ and i_ args cannot be lagged.\
				
\f0\b \\ir
\f1\b0 		the Control can be set only at creation ('initial rate'): see i_ argument above\
				
\f0\b \\tr
\f1\b0 		the Control is used as a trigger: see t_ argument above\
		\
	\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 *writeOnce(synthDefName,ugenGraphFunc, rates, prependArgs, dir)\
			\
			
\f1\b0 Create a new SynthDef and write it to disk, providing a def file with this name does not \
			already exist. This is useful in class definitions so that the def is not written every time the library \
			is compiled. Note that this will not check for differences, so you will need to delete the defFile to \
			get it to rebuild. Default for dir is synthdefs/\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs26 \cf0 \ul \ulc0 Instance Methods
\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \ulnone 	\
	
\f0\b \
		name
\f1\b0 \
			return my name.\
			a SynthDef is always referred to by its name, which should be unique.\
		
\f0\b \
		writeDefFile(dir)
\f1\b0 \
			encode the graph into a file called name.scsyndef. Default for dir = synthdefs/
\f0\b \
		\
		store(libname, dir, completionMessage)\
		
\f1\b0 	write the defFile and store it in the SynthDescLib.\
			send a message to the library's server to load this file.\
			when this asynchronous command is completed, the completionMessage (a valid OSC \
			message) is immediately executed by the server.\
			default for libname is \\global, for dir is synthdefs/\
			
\f0\b \
		load(server, completionMessage, dir)\
		
\f1\b0 	write the defFile and send a message to the server to load this file.\
			when this asynchronous command is completed, the completionMessage (a valid OSC \
			message) is immediately executed by the server.\
			default for dir is synthdefs/\
		\
		
\f0\b send(server, completionMessage)\
		
\f1\b0 	compile the def and send it to the server without writing to disk.\
			(thus avoiding that annoying SynthDef buildup)\
			when this asynchronous command is completed, the completionMessage (a valid OSC \
			message) is immediately executed by the server.\
		\
		
\f0\b play(target, args, addAction)\
		
\f1\b0 	write the defFile and send a message to the server specified by target to load this file.\
			when this asynchronous command is completed, play one synth from this definition.\
			returns a 
\f0\b Synth
\f1\b0  object.\
			for a list of valid addActions see 
\f0\b Synth
\f1\b0 . The default is \cf2 \\addToHead\cf0 \
		\
	\
see also basic introductions, like 
\f0\b SynthDefsVsSynths
\f1\b0 \
	\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs32 \cf0 \ul \ulc0 Examples
\f1\b0\fs24 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf0 \ulnone \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // Note that SynthDef(...) is short for SynthDef.new(...).\cf0 \
\cf3 // Thus the following calls *new to create a SynthDef, and then .play on the resulting instance.\cf0 \
\cf3 // It is common to use similar constructions for .send, .store, and so on.\cf0 \
\
(\
d = \cf4 SynthDef\cf0 (\cf5 "trigTest"\cf0 , \{ \cf4 arg\cf0  t_trig=0, freq=440; \cf3 // t_trig creates a TrigControl\cf0 \
	\cf4 Out\cf0 .ar(0, \cf4 SinOsc\cf0 .ar(freq+[0,1], 0, \cf4 Decay2\cf0 .kr(t_trig, 0.005, 1.0)));\
\
	\}, [0, 4]		\cf3 // lag the freq, but not t_trig (won't work anyway)\cf0 \
);\
)\
\
\cf3 //if rates are used, the above can be written also like this:\cf0 \
(\
d = \cf4 SynthDef\cf0 (\cf5 "trigTest"\cf0 , \{ \cf4 arg\cf0  trig=0, freq=440; \
	\cf4 Out\cf0 .ar(0, \cf4 SinOsc\cf0 .ar(freq+[0,1], 0, \cf4 Decay2\cf0 .kr(trig, 0.005, 1.0)));\
	\}, [\cf2 \\tr\cf0 , 4]		\cf3 // lag the freq (lagtime: 4s), \\tr creates a TrigControl for trig\cf0 \
); 		\
)\
\
\cf3 //send the def to the local server:\cf0 \
s = \cf4 Server\cf0 .local;\
d.send(s);\
\
\cf3 //create a synth on the server with the synthdef name:\cf0 \
\
z = \cf4 Synth\cf0 .head(s, \cf2 \\trigTest\cf0 );\
z.set(\cf2 \\trig\cf0 , 1); 				\cf3 // you can do this multiple times \cf0 \
z.set(\cf2 \\trig\cf0 , 1, \cf2 \\freq\cf0 , 220); 	\cf3 // hear how the freq lags\cf0 \
z.set(\cf2 \\trig\cf0 , 1, \cf2 \\freq\cf0 , 880);\
\
z.free; \cf3 //free the synth
\f1\fs24 \cf0 \
\
\

\f4\fs18 \cf3 //play shortcut syntax: this syntax is used in many helpfiles.
\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf0 z = d.play(s); \cf3 // .play returns a Synth object, assigned here to z. sending the def is done internally.\
\cf0 z.set(\cf2 \\trig\cf0 , 1);
\f1\fs24 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 common argument names: 
\f3\i out
\f0\i0  
\f1\b0 and
\f0\b  
\f3\i gate
\f1\i0\b0 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f4\fs18 \cf0 (\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf4 SynthDef\cf0 (\cf2 \\synthDefTest\cf0 , \{ \cf4 arg\cf0  out, gate=1, freq=440; \
		\cf4 Out\cf0 .ar(out, \cf4 SinOsc\cf0 .ar(freq) * \cf4 EnvGen\cf0 .kr(\cf4 Env\cf0 .asr(0.1, 0.3, 1.3), gate, doneAction:2));\
\
	\}).store; 		\
)\
\
x = \cf4 Synth\cf0 (\cf2 \\synthDefTest\cf0 , [\cf2 \\out\cf0 , 0]); \cf3 //play out through hardware output bus 0 (see Out.help)\cf0 \
x.release;\cf3 //releases and frees the synth, if and only if doneAction is > 2\cf0 \
\
\cf3 //equivalent:\cf0 \
\
x = \cf4 Synth\cf0 (\cf2 \\synthDefTest\cf0 ); \cf3 // out defaults to zero, if no default arg is given.\cf0 \
x.set(\cf2 \\gate\cf0 , 0); \cf3 //releases and frees the synth, if and only if doneAction is > 2\cf0 \
\
\cf3 //if value is negative, it describes the release time:\cf0 \
\
x = \cf4 Synth\cf0 (\cf2 \\synthDefTest\cf0 );\
x.set(\cf2 \\gate\cf0 , -5);\
\
\
\cf3 //equivalent:\cf0 \
x = \cf4 Synth\cf0 (\cf2 \\synthDefTest\cf0 );\
x.release(5);\
\
\
\
\cf3 //if the out arg is used in a standard way, it can always be changed without knowing the synth def\cf0 \
x = \cf4 Synth\cf0 (\cf2 \\synthDefTest\cf0 , [\cf2 \\out\cf0 , 0]);\
x.set(\cf2 \\out\cf0 , 1); \cf3 //play through channel 1\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 x.release;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 //also it can be used in an event stream:\cf0 \
\cf3 //if the doneAction is 1 the synths pile up and do not get freed.\cf0 \
(\
\cf4 Pbind\cf0 (\
	\cf2 \\instrument\cf0 , \cf2 \\synthDefTest\cf0 ,\
	\cf2 \\freq\cf0 , \cf4 Pseq\cf0 ([500, 600, \cf4 Prand\cf0 ([200, 456, 345],1)], \cf4 inf\cf0 ),\
	\cf2 \\legato\cf0 , \cf4 Pseq\cf0 ([1.5, 0.2], \cf4 inf\cf0 ),\
	\cf2 \\dur\cf0 , 0.4\
).play;\
)\
\
\
\
}