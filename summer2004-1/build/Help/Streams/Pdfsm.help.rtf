{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red0\green115\blue0;
\red0\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf2 \
Pdfsm\cf0  - deterministic finite state machine\
\

\fs32 by ccos
\fs36 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \

\f0\b superclass: \cf2 ListPattern\cf0  \

\f1\b0 \
deterministic finite state machine with signal input.\
based on the fsm described by Minsky in 'Computation, Finite and Infinite Machines'.\
\

\f0\b list - 			
\f1\b0 a list consisting of the stream which gives input signals to determine state \
			transitions, and then dictionary entries, one for each state, mapping the destinattion\
			state and yield streams to those input signals.\

\f0\b startState -
\f1\b0  	 an integer index for the state to start with. defaults to 0.\

\f0\b repeats -
\f1\b0  		an integer giving the number of times the pattern should cycle.\
			a cycle ends when the 
\f0\b signal stream
\f1\b0  ends or \cf2 nil\cf0  is given for the destination \
			state to a signal value, see below. defaults to 1\
\

\f0\b more on the list -\

\f1\b0 \
	[\
		
\f0\b signal stream - 
\f1\b0 can be a stream of anything
\f0\b  
\f1\b0 which can serve as a key for\
					an associative collection. integers, symbols, etc...\
					asStream is called on this for each repeat.\
		
\f0\b states - 		
\f1\b0 states should be \cf2 IdentityDictionaries\cf0  or some other associative collection\
	]\
\

\f0\b list syntax	-\

\f1\b0 \
	[	\
		
\f0\b signal stream,
\f1\b0 	\
		( \cf3 // state 0, \cf0 \
		 	
\f0\b signal value
\f1\b0   :  [
\f0\b destination state, return stream or pattern
\f1\b0 ],\
		 	
\f0\b signal value
\f1\b0   :  [
\f0\b destination state, return stream or pattern
\f1\b0 ]\
		 ),\
		 ... \cf3 // state 1 ... N\cf0 \
	]\
	\
any number of states can be given, and are indexed by the order in which they are given.\
if the fsm is in state x and it receives a 
\f0\b signal value
\f1\b0  y it looks up y in the state dictionary \
supplied for x, if there is no y entry, it looks for a \cf4 \\default\cf0  entry and uses that. \
the next state is then set to 
\f0\b destination state
\f1\b0 , and the stream yielded is given by 
\f0\b return stream or pattern.\

\f1\b0 that is unless the 
\f0\b destination state
\f1\b0  is given as \cf2 nil\cf0 , or if a 
\f0\b destination state
\f1\b0  is given for which you have
\f0\b  
\f1\b0 not \
supplied a dictionary - in both cases the current cycle ends and any remaining repeats are executed.\
if there is no 
\f0\b signal value
\f1\b0  given for a particular signal, and no \cf4 \\default\cf0   is supplied then upi will get a runtime error.
\f2\fs18 \
\
(\
	p = \cf2 Pdfsm\cf0 (\
		[\
			\cf2 Pseq\cf0 ( [\cf4 \\foo\cf0 ,\cf4 \\bar\cf0 ], 2 ), \cf3 // foobar signals	\cf0 \
			( \cf3 // state 0\cf0 \
				\cf4 \\foo\cf0  : [ 1, \cf2 Pseq\cf0 ([ 0, 1 ], 2 ) ]\
			),\
			( \cf3 // state 1\cf0 \
				\cf4 \\bar\cf0  : [ 0, 3 ]\
			)\
		],\
		0,   \
		2\
	).asStream;\
	\
	11.do(\{ p.next.postln \});\
)
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 (\
\cf2 SynthDef\cf0 (\cf4 'Help-Pdfsm1'\cf0 , \
	\{ \cf2 arg\cf0  out=0, freq=440, dur=0.05;\
		\cf2 var\cf0  env;\
		env = \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .perc(0.01, dur, 0.2), doneAction:2);\
		\cf2 Out\cf0 .ar(out, \cf2 SinOsc\cf0 .ar([freq, freq + 0.1.rand2], 0, env))\
	\}).send(s);\
)\
\
(\
\cf2 var\cf0  p;\
p = \cf2 Pdfsm\cf0 (\
	[\
		\cf2 Prand\cf0 ([0,1,2],\cf2 inf\cf0 ), 	\cf3 // signalStream\cf0 \
	\
		\cf2 IdentityDictionary\cf0 [ 	\cf3 // state 0\cf0 \
			0 -> [ 2, \cf2 Pseq\cf0 ([67,68,69], 2) ],\
			1 -> [ 0, 66 ],\
			2 -> [ 1, 65 ]\
		],\
		\cf2 IdentityDictionary\cf0 [ 	\cf3 // state 1\cf0 \
			1 -> [ 1, \cf2 Pseq\cf0 ([69,68,67],2) ],\
			\cf4 \\default\cf0  -> [ 0, 70 ]\
		],\
		\cf2 IdentityDictionary\cf0 [\
			0 -> [ 0, 71 ],\
			1 -> [ 0, 72 ],\
			2 -> [ \cf2 nil\cf0  ]  \cf3 // signalStream is infinitely long,\cf0 \
						\cf3 // so the fsm only ends because of this nil\
\cf0 	\cf3 					// 2 -> [nil, nil] is also fine\cf0 \
		]\
	],\
	1, 					\cf3 // startState\cf0 \
	1 					\cf3 // repeats \cf0 \
).asStream;\
\
\cf2 Routine\cf0 (\{\
	\cf2 var\cf0  freq;\
	while(\{ (freq = p.next.postln).notNil \},\{\
		\cf2 Synth\cf0 (\cf4 'Help-Pdfsm1'\cf0 , [ \cf4 \\freq\cf0 , freq.midicps ]);\
		0.1.wait;\
	\})\
\}).play;\
)\
\cf5 \
(\
\cf6 SynthDef\cf5 (\cf7 'Help-Pdfsm2'\cf5 , \
	\{ \cf6 arg\cf5  freq, gate=1;\
		\cf6 var\cf5  n=8, env, osc;\
		env = \cf6 Linen\cf5 .kr( gate, 0.01, 1, 0.03, 2 );\
		osc = \{\cf6 Mix\cf5 .fill( n, \{ \cf6 arg\cf5  i;\
			\cf6 FSinOsc\cf5 .ar(freq + \cf6 Rand\cf5 (-2.0,2.0), \cf6 Rand\cf5 (0, 0.05pi)) ring4:\
			\cf6 FSinOsc\cf5 .ar(freq * (i+1));\
		\})\}.dup * \cf6 FSinOsc\cf5 .kr(\cf6 Rand\cf5 (1.5,4.5),\{\cf6 Rand\cf5 (-0.1pi,0.1pi)\}.dup,0.6,env*0.4);\
		\cf6 Out\cf5 .ar(0, env * osc / (n*4)  )\
	\}).load(s);\
	\cf6 SynthDescLib\cf5 .global.read; \cf8 // needed for the Pbinds below\cf5 \
)\
\cf0 \
(\
\cf2 var\cf0  n=3, base, penult;\
\
base = [3,4,4,0];\
\
for( 1, n, \{ \cf2 arg\cf0  i;\
	penult = \cf2 Pbind\cf0 ( \cf4 \\degree\cf0 , \cf2 Pshuf\cf0 (base - (i*5), 2), \cf4 \\dur\cf0 , \cf2 Pseq\cf0 ([0.2],2) );\
	\cf2 Pset\cf0 (\
		\cf4 \\instrument\cf0 , \cf4 'Help-Pdfsm2'\cf0 ,\
		\cf2 Pdfsm\cf0 (\
			[\
				\cf2 Pseq\cf0 ([	\cf3 // signalStream\cf0 \
					\cf2 Pn\cf0 (1,22 + i),\
					\cf2 Pn\cf0 (0,4),\
					\cf2 Pn\cf0 (1,8),\
					\cf2 Pseq\cf0 ([ 						\
						\cf2 Pn\cf0 (0,3), \
						\cf2 Prand\cf0 ([0,1],8), \
						\cf2 Pn\cf0 (1,8) \
					], 3 ),\
					\cf2 Pn\cf0 (2,2)\
				], 1 ), \
				(		\cf3 // state 0\cf0 \
					0 : [ 0, \cf2 Pbind\cf0 ( \cf4 \\degree\cf0 , \cf2 Pseq\cf0 (base - i, 1), \cf4 \\dur\cf0 , \cf2 Pxrand\cf0 ([0.2,0.3],4) ) ],\
					1 : [ 1, \cf2 Pbind\cf0 ( \cf4 \\degree\cf0 , \cf2 Pseq\cf0 (base.reverse - (i*2), 2), \cf4 \\dur\cf0 , \cf2 Pseq\cf0 ([0.2,0.21],1) ) ],\
					2 :	[ 2, penult ]\
				),\
				(		\cf3 // state 1\cf0 \
					0 : [ 0, \cf2 Pbind\cf0 ( \cf4 \\degree\cf0 , \cf2 Pshuf\cf0 (base * i.neg, 8), \cf4 \\dur\cf0 , \cf2 Pseq\cf0 ([0.08],8) ) ],\
					1 : [ 0, \cf2 Pbind\cf0 ( \cf4 \\degree\cf0 , \cf2 Pseq\cf0 (base - (i*3),3+i), \cf4 \\dur\cf0 , \cf2 Pseq\cf0 ([0.11],3+i) ) ],\
					2 : [ 2, penult ]\
				),\
				(		\cf3 // state 2\cf0 \
					\cf4 \\default\cf0  : [ 2, \cf2 Pbind\cf0 ( \cf4 \\degree\cf0 , \cf2 Prand\cf0 (base - (i*7), 5), \cf4 \\dur\cf0 , \cf2 Prand\cf0 ([0.6,0.8],5) ) ]\
				)\
			],\
			i%2 		\cf3 // startState\cf0 \
		)\
	).play;\
\})\
)\
\
\
}