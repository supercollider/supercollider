{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 LocalIn
\fs28 				define and read from buses local to a SynthDef\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs18 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 superclass: AbstractIn
\f2\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs18 \cf2 \
\cf0 	
\f0\b\fs24 *ar(numChannels) 
\f2\b0 - define and read from an audio bus local to the SynthDef.
\f0\b \
	*kr(numChannels) 
\f2\b0 -
\f0\b  
\f2\b0 define and read from a control bus local to the SynthDef.\
\
		
\f0\b numChannels 
\f2\b0 - the number of channels of local buses. The default is 1.
\f1\fs18 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 LocalIn
\f2\b0  defines buses that are local to the SynthDef. These are like the global buses, but are more convenient if you want to implement a self contained effect that uses a feedback processing loop.\
There can only be one audio rate and one control rate 
\f0\b LocalIn
\f2\b0  per SynthDef.\
The audio can be written to the bus using 
\f0\b LocalOut
\f2\b0 .\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs20 \cf0 (\
\{\
	\cf2 var\cf0  source, local;\
	\
	source = \cf2 Decay\cf0 .ar(\cf2 Impulse\cf0 .ar(0.3), 0.1) * \cf2 WhiteNoise\cf0 .ar(0.2);\
	\
	local = \cf2 LocalIn\cf0 .ar(2) + [source, 0]; \cf3 // read feedback, add to source\cf0 \
	\
	local = \cf2 DelayN\cf0 .ar(local, 0.2, 0.2); \cf3 // delay sound\cf0 \
	\
	\cf3 // reverse channels to give ping pong effect, apply decay factor\cf0 \
	\cf2 LocalOut\cf0 .ar(local.reverse * 0.8); \
	\
	\cf2 Out\cf0 .ar(0, local);\
\}.play;\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs20 \cf0 (\
z = \cf2 SynthDef\cf0 (\cf4 "tank"\cf0 , \{\
	\cf2 var\cf0  local, in;\
	\
	in = \cf2 Mix\cf0 .fill(12, \{ \
		\cf2 Pan2\cf0 .ar(\
			\cf2 Decay2\cf0 .ar(\cf2 Dust\cf0 .ar(0.05), 0.1, 0.5, 0.1) \
				* \cf2 FSinOsc\cf0 .ar(\cf2 IRand\cf0 (36,84).midicps).cubed.max(0), \
			\cf2 Rand\cf0 (-1,1))\
	\});\
	in = in + \cf2 Pan2\cf0 .ar(\cf2 Decay2\cf0 .ar(\cf2 Dust\cf0 .ar(0.03), 0.04, 0.3) * \cf2 BrownNoise\cf0 .ar, 0);\
	\
	4.do \{ in = \cf2 AllpassN\cf0 .ar(in, 0.03, \{\cf2 Rand\cf0 (0.005,0.02)\}.dup, 1); \};\
	\
	local = \cf2 LocalIn\cf0 .ar(2) * 0.98;\
	local = \cf2 OnePole\cf0 .ar(local, \cf2 0.5\cf0 );\
	\
	local = \cf2 Rotate2\cf0 .ar(local[0], local[1], 0.23);\
	local = \cf2 AllpassN\cf0 .ar(local, 0.05, \{\cf2 Rand\cf0 (0.01,0.05)\}.dup, 2);\
	 			\
	local = \cf2 DelayN\cf0 .ar(local, 0.3, [0.19,0.26]);\
	local = \cf2 AllpassN\cf0 .ar(local, 0.05, \{\cf2 Rand\cf0 (0.03,0.15)\}.dup, 2);\
	\
	local = \cf2 LeakDC\cf0 .ar(local);	\
	local = local + in;\
		\
	\cf2 LocalOut\cf0 .ar(local);\
	\
	\cf2 Out\cf0 .ar(0, local);\
\}).play;\
)\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs20 \cf0 (\
z = \cf2 SynthDef\cf0 (\cf4 "tape"\cf0 , \{\
	\cf2 var\cf0  local, in, amp;\
	\
	in = \cf2 AudioIn\cf0 .ar([1,2]);\
	\
	amp = \cf2 Amplitude\cf0 .kr(\cf2 Mix\cf0 .ar(in));\
	in = in * (amp > 0.02); \cf3 // noise gate\cf0 \
	\
	local = \cf2 LocalIn\cf0 .ar(2);\
	local = \cf2 OnePole\cf0 .ar(local, 0.4);\
	local = \cf2 OnePole\cf0 .ar(local, -0.08);\
	\
	local = \cf2 Rotate2\cf0 .ar(local[0], local[1], 0.2);\
	 			\
	local = \cf2 DelayN\cf0 .ar(local, 0.25, 0.25);\
	\
	local = \cf2 LeakDC\cf0 .ar(local);	\
	local = ((local + in) * 1.25).softclip;\
		\
	\cf2 LocalOut\cf0 .ar(local);\
	\
	\cf2 Out\cf0 .ar(0, local * 0.1);\
\}).play;\
)\
}