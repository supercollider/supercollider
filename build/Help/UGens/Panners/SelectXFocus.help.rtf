{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 SelectXFocus				
\fs24 mix one output from many sources
\f1\b0\fs18 \cf2 \
\

\f2\fs24 \cf0 \
superclass: Object\
\
The output is mixed from an array of inputs, linearly interpolating from a number of adjacent channels.\
A focus argument allows to control how many adjacent sources are mixed. (by adc)\

\f1\fs18 \cf2 \

\f0\b\fs24 \cf0 	SelectXFocus.ar(which, array, focus)\
	SelectXFocus.kr(which, array, focus)\

\f1\b0\fs18 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // examples \cf0 \
(\
\{\
	\cf2 var\cf0  a;\
	a = [\
			\cf2 Saw\cf0 .ar(\cf2 LFSaw\cf0 .kr(3 * [1, 1.01], 0, 100, 230)),\
			\cf2 SinOsc\cf0 .ar,\
			\cf2 Pulse\cf0 .ar(\cf2 LFPulse\cf0 .kr(3 * [1, 1.02], 0, 0.4, 100, 230)),\
			\cf2 SinOsc\cf0 .ar(\cf2 SinOsc\cf0 .kr(4 * [1, 1.03], 0, 200, 300))\
		];\
	\
	\cf2 SelectXFocus\cf0 .ar(\cf2 MouseX\cf0 .kr(0, 1) * a.size, a, \cf2 MouseY\cf0 .kr(0, a.size)) * 0.2\
\}.play;\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 	\

\f2\fs24 \cf0 Note: all the ugens are continously running. This may not be the most efficient way if each input is  cpu-expensive. The array is fixed at the time of writing the SynthDef, and the whole array is embedded in the SynthDef file itself.  For small arrays this is more efficient than reading from a buffer.\

\f1\fs18 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\
// radio tuner\
// (jrh) (cc 2006)\cf0 \
(\
\{\
	\cf2 var\cf0  a, n, mx, my, mwrap;\
	n = 8;\
	mx = \cf2 MouseX\cf0 .kr(0, 1, 0, 0.1);\
	my = \cf2 MouseY\cf0 .kr;\
	mwrap = \{ \cf2 |pmin, pmax, min, max|\cf0  sin(mx * \cf2 ExpRand\cf0 (pmin, pmax)) + 1 * 0.5 * \cf2 ExpRand\cf0 (min, max) \};\
	a = \{\
		\cf2 var\cf0  freq, fmul, phase;\
		freq = mwrap.(10, 40, 200, 5000) + \cf2 ExpRand\cf0 (200, 3000);\
		fmul = \cf2 LFNoise0\cf0 .kr(\cf2 ExpRand\cf0 (0.1, 8)).round(1/6).exprange(1, \cf2 Rand\cf0 (1, 1.2));\
		phase = \cf2 LFNoise2\cf0 .ar(mwrap.(1, 20, 10, 1000), \cf2 Rand\cf0 (2, 5));\
		\cf2 SinOsc\cf0 .ar(freq * fmul, phase)\
	\} ! n;\
	\cf2 SelectXFocus\cf0 .ar(mx * n, a, my * n) * 0.2 + \cf2 OnePole\cf0 .ar(\cf2 PinkNoise\cf0 .ar(0.5 ! 2), 0.4) \
	* \cf2 Line\cf0 .kr(0, 1, 3);\
\}.play;\
)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 \
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 // jimmy played harmonica in the pub where I was born\cf0 \
\cf3 // (hh) (jrh) (cc 2006)\cf0 \
(\
\{\
	\cf2 var\cf0  blas, zieh, mx, my, trig, which, amp, u, schnauf;\
	\cf2 var\cf0  del = 9, det = 0.1;\
	schnauf = 0.3;\
	mx = \cf2 MouseX\cf0 .kr;\
	my = \cf2 MouseY\cf0 .kr(0.1, 2, 1);\
	\
	blas = [0, 12, 24] +.x [60, 64, 67] ++ [60+36];\
	zieh = [62, 67, 71,   74, 77, 81, 83,   86, 89, 93];\
\
	trig = \cf2 Dust\cf0 .kr(1);\
	which = \cf2 ToggleFF\cf0 .kr(\cf2 TDelay\cf0 .kr(trig, schnauf));\
	amp = \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 ([1, 0, 1], [schnauf, schnauf]), trig);\
	blas = \cf2 Select\cf0 .kr(which, [blas, zieh]);\
	u = \cf2 SelectXFocus\cf0 .ar(\
		mx * blas.size,	\
		blas.collect \{\cf2 |f|\cf0 \
			\cf2 Pulse\cf0 .ar((\cf2 Rand\cf0 (-0.04, 0.09) + f).midicps, \cf2 0.48\cf0  + \cf2 LFNoise1\cf0 .kr(0.06, 0.1), 0.2)\
		\},\
		my\
	) * \cf2 Slope\cf0 .kr(mx + my).abs.lag2(2) * amp;\
	u = \cf2 Pan2\cf0 .ar(\cf2 OnePole\cf0 .ar(u, -0.3), mx * 2 - 1);\
	\cf2 DelayL\cf0 .ar(\cf2 BPF\cf0 .ar(u * 2, 1500, 0.3), del + det, \cf2 LFNoise2\cf0 .kr(0.2, det, del)) + u\
\}.play;\
);\
\
\
}