{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf420
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Oblique;
\f3\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Buffer					
\fs24 client-side representation of a buffer on a server\

\f1\b0 \

\f0\b superclass: Object
\f1\b0 \
\
Buffer encapsulates a number of common tasks, OSC messages, and capabilities related to server-side buffers, which are globally available arrays of floats. These are commonly used to hold sampled audio, such as a soundfile loaded into memory, but can be used to hold other types of data as well. They can be freed or altered even while being accessed.  Buffers are commonly used with 
\f0\b PlayBuf
\f1\b0 , 
\f0\b RecordBuf
\f1\b0 , 
\f0\b DiskIn
\f1\b0 , 
\f0\b DiskOut
\f1\b0 , 
\f0\b BufWr
\f1\b0 , 
\f0\b BufRd
\f1\b0 , and other UGens. (See their individual help files for more examples.) See 
\f0\b Server-Architecture
\f1\b0  for more details.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Buffer Numbers and Allocation\ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \
Although the number of buffers on a server is set at the time it is booted, memory must still be allocated within the server app before they can hold values. (At boot time all buffers have a size of 0.) \
\
Server-side buffers are identified by number, starting from 0. When using Buffer objects, buffer numbers are automatically allocated from the Server's bufferAllocator, unless you explicitly supply one. When you call 
\f0\b .free
\f1\b0  on a Buffer object it will release the buffer's memory on the server, and free the buffer number for future reallocation. See 
\f0\b ServerOptions
\f1\b0  for details on setting the number of available buffers.\
\
Normally you should not need to supply a buffer number. You should only do so if you are sure you know what you are doing.\
\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural
\cf0 You can control which allocator determines the buffer index numbers by setting the server options 
\f0\b blockAllocClass
\f1\b0  variable prior to booting the server. Two allocators are available to support different kinds of applications. See the 
\f0\b \ul [ServerOptions]
\f1\b0 \ulnone  help file for details.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Multichannel Buffers\ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \
Multichannel buffers interleave their data. Thus the actual number of available values when requesting or setting values by index using methods such as set, setn, get, getn, etc., is equal to numFrames * numChannels. Indices start at 0 and go up to (numFrames * numChannels) - 1. In a two channel buffer for instance, index 0 will be the first value of the first channel, index 1 will be the first value of the second channel, index 2 will be the second value of the first channel, and so on.\
\
In some cases it is simpler to use multiple single channel buffers instead of a single multichannel one.\

\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 Completion Messages and Action Functions\ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs24 \cf0 \ulnone \
Many buffer operations (such as reading and writing files) are asynchronous, meaning that they will take an arbitrary amount of time to complete. Asynchronous commands are passed to a background thread on the server so as not to steal CPU time from the audio synthesis thread. Since they can last an aribitrary amount of time it is convenient to be able to specify something else that can be done immediately on completion. The ability to do this is implemented in two ways in Buffer's various methods: completion messages and action functions. \
\
A completion message is a second OSC command which is included in the message which is sent to the server. (See 
\f0\b NodeMessaging
\f1\b0  for a discussion of OSC messages.) The server will execute this immediately upon completing the first command. An action function is a 
\f0\b Function
\f1\b0  which will be evaluated when the client receives the appropriate reply from the server, indicating that the previous command is done. Action functions are therefore inherently more flexible than completion messages, but slightly less efficient due to the small amount of added latency involved in message traffic. Action functions are passed the Buffer object as an argument when they are evaluated.\
\
With Buffer methods that take a completion message, it is also possible to pass in a function that returns an OSC message. As in action functions this will be passed the Buffer as an argument. It is important to understand however that this function will be evaluated after the Buffer object has been created (so that its bufnum and other details are accessible), but 
\f2\i before
\f1\i0  the corresponding message is sent to the server.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural

\f0\b\fs28 \cf0 Bundling
\f1\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
Many of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an 
\f0\b Array
\f1\b0  so that it can be added to a bundle. It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities. See 
\f0\b Server
\f1\b0  and 
\f0\b bundledCommands
\f1\b0  for more details.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural

\f0\b\fs28 \cf0 \ul \ulc0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ri-620\ql\qnatural
\cf0 \ulnone Accessing Instance Variables
\f1\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 The following variables have getter methods.\
\
	
\f0\b server
\f1\b0  - Returns the Buffer's 
\f0\b Server
\f1\b0  object.\
	\
	
\f0\b bufnum
\f1\b0  - Returns the buffer number of the corresponding server-side buffer.\
\
	
\f0\b numFrames
\f1\b0  - Returns the number of sample frames in the corresponding server-side buffer. Note that multichannel buffers interleave their samples, so when dealing with indices in methods like get and getn, the actual number of available values is numFrames * numChannels.\
	\
	
\f0\b numChannels
\f1\b0  - Returns the number of channels in the corresponding server-side buffer. \
	\
	
\f0\b sampleRate
\f1\b0  - Returns the sample rate of the corresponding server-side buffer.\
	\
	
\f0\b path
\f1\b0  - Returns a string containing the path of a soundfile that has been loaded into the corresponding server-side buffer.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\
		
\f3\fs18 s.boot;\
		b = \cf2 Buffer\cf0 .alloc(s,44100 * 8.0,2);\
		b.bufnum.postln;\
		b.free;\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Creation with Immediate Memory Allocation
\f3\b0\fs18 \
	\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f0\b\fs24 \cf0 	*alloc(server, numFrames, numChannels, completionMessage, bufnum)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f3\b0\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\fs24 \cf0 		Create and return a Buffer and immediately allocate the required memory on the server. The buffer's values will be initialised to 0.0.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		
\f0\b server 
\f1\b0  - The server on which to allocate the buffer. The default is the default 
\f0\b Server
\f1\b0 .\
		
\f0\b numFrames 
\f1\b0 - The number of frames to allocate. Actual memory use will correspond to numFrames * numChannels.\
		
\f0\b numChannels
\f1\b0  - The number of channels for the Buffer. The default is 1.\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
		
\f0\b bufnum
\f1\b0  - An explicitly specified buffer number. Generally this is not needed.\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f3\fs18 \cf0 		\cf3 // Allocate 8 second stereo buffer\cf0 \
		s.boot;\
		b = \cf2 Buffer\cf0 .alloc(s, s.sampleRate * 8.0, 2);\
		b.free;\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\fs24 \cf0 	*
\f0\b allocConsecutive(numBufs, server, numFrames, numChannels, completionMessage, bufnum) 
\f1\b0 \
\
		Allocates a range of consecutively-numbered buffers, for use with UGens like 
\f0\b [\ul VOsc\ulnone ]
\f1\b0  and 
\f0\b [\ul VOsc3\ulnone ] 
\f1\b0 that require a contiguous block of buffers, and returns an array of corresponding Buffer objects.\
		\
		
\f0\b numBufs
\f1\b0  - The number of consecutively indexed buffers to allocate.\
		
\f0\b server 
\f1\b0  - The server on which to allocate the buffers. The default is the default 
\f0\b Server
\f1\b0 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		
\f0\b numFrames 
\f1\b0 - The number of frames to allocate in each buffer. Actual memory use will correspond to numFrames * numChannels.\
		
\f0\b numChannels
\f1\b0  - The number of channels for each buffer. The default is 1.\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed each Buffer and its index in the array as arguments when evaluated.\
		
\f0\b bufnum
\f1\b0  - An explicitly specified buffer number for the initial buffer. Generally this is not needed.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 \
		
\f0\b N.B.
\f1\b0  You must treat the array of Buffers as a group. Freeing them individually or resuing them can result in allocation errors. You should free all Buffers in the array at the same time by iterating over it with 
\f0\b do
\f1\b0 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf0 \
		s.boot;\
		\cf3 // allocate an array of Buffers and fill them with different harmonics\cf0 \
		(\
		b = \cf2 Buffer\cf0 .allocConsecutive(8, s, 4096, 1, \{ \cf2 |buf, i|\cf0 \
			buf.sine1Msg((1..((i+1)*6)).reciprocal) \cf3 // completion Messages\cf0 \
		\});\
		)\
		a = \{ \cf2 VOsc\cf0 .ar(\cf2 SinOsc\cf0 .kr(0.5, 0).range(b.first.bufnum + 0.1, b.last.bufnum - 0.1)\
			[440, 441], 0, 0.2) \}.play;\
		\
		a.free; \
		\
		\cf3 // iterate over the array and free it
\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		
\f3\fs18 b.do(\cf2 _\cf0 .free);
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f3\fs18 \cf0 	
\f0\b\fs24 *read(server, path, startFrame, numFrames, action, bufnum)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Allocate a buffer and immediately read a soundfile into it. This method sends a query message as a completion message so that the Buffer's instance variables will be updated automatically. 
\f0\b N.B.
\f1\b0  You cannot rely on the buffer's instance variables being instantly updated, as there is a small amount of latency involved. 
\f0\b action
\f1\b0  will be evaluated upon receipt of the reply to the query, so use this in cases where access to instance variables is needed.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
		
\f0\b server 
\f1\b0  - The server on which to allocate the buffer.\
		
\f0\b path
\f1\b0  - A 
\f0\b String
\f1\b0  representing the path of the soundfile to be read.\
		
\f0\b startFrame
\f1\b0  - The first frame of the soundfile to read. The default is 0, which is the beginning of the file.\
		
\f0\b numFrames 
\f1\b0 - The number of frames to read. The default is -1, which will read the whole file.\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.\
		
\f0\b bufnum
\f1\b0  - An explicitly specified buffer number. Generally this is not needed.
\f3\fs18 \
	\
		\cf3 // read a soundfile\cf0 \
		s.boot;\
		b = \cf2 Buffer\cf0 .read(s, \cf4 "sounds/a11wlk01.wav"\cf0 );\
		\
		\cf3 // now play it\cf0 \
		(\
		x = \cf2 SynthDef\cf0 (\cf4 "help-Buffer"\cf0 ,\{ \cf2 arg\cf0  out = 0, bufnum;\
			\cf2 Out\cf0 .ar( out,\
				\cf2 PlayBuf\cf0 .ar(1, bufnum, \cf2 BufRateScale\cf0 .kr(bufnum))\
			)\
		\}).play(s,[\cf5 \\bufnum\cf0 , b.bufnum ]);\
		)\
		x.free; b.free;\
		\
		\cf3 // with an action function\cf0 \
		\cf3 // note that the vars are not immediately up-to-date\cf0 \
		(\
		b = \cf2 Buffer\cf0 .read(s, \cf4 "sounds/a11wlk01.wav"\cf0 , action: \{ \cf2 arg\cf0  buffer; \
			(\cf4 "After update:"\cf0  + buffer.numFrames).postln;\
			x = \{ \cf2 PlayBuf\cf0 .ar(1, buffer.bufnum, \cf2 BufRateScale\cf0 .kr(buffer.bufnum)) \}.play;\
		\});\
		(\cf4 "Before update:"\cf0  + b.numFrames).postln;\
		)\
		x.free; b.free;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 	
\f0\b\fs24 *readChannel(server, path, startFrame, numFrames, channels, action, bufnum)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		As 
\f0\b *read
\f1\b0  above, but takes an Array of channel indices to read in, allowing one to read only the selected channels.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
		
\f0\b server 
\f1\b0  - The server on which to allocate the buffer.\
		
\f0\b path
\f1\b0  - A 
\f0\b String
\f1\b0  representing the path of the soundfile to be read.\
		
\f0\b startFrame
\f1\b0  - The first frame of the soundfile to read. The default is 0, which is the beginning of the file.\
		
\f0\b numFrames 
\f1\b0 - The number of frames to read. The default is -1, which will read the whole file.\
		
\f0\b channels
\f1\b0  - An 
\f0\b Array
\f1\b0  of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided.\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.\
		
\f0\b bufnum
\f1\b0  - An explicitly specified buffer number. Generally this is not needed.
\f3\fs18 \
	\
		s.boot;\
		\cf3 // first a standard read so we can see what's in the file\cf0 \
		b = \cf2 Buffer\cf0 .read(s, \cf4 "sounds/SinedPink.aiff"\cf0 );\
		\cf3 // "sounds/SinedPink.aiff" contains SinOsc on left, PinkNoise on right\cf0 \
		b.plot;\
		b.free;\
		\
		\cf3 // Now just the sine\cf0 \
		b = \cf2 Buffer\cf0 .readChannel(s, \cf4 "sounds/SinedPink.aiff"\cf0 , channels: [0]);\
		b.plot;\
		b.free;\
		\
		\cf3 // Now just the pink noise\cf0 \
		b = \cf2 Buffer\cf0 .readChannel(s, \cf4 "sounds/SinedPink.aiff"\cf0 , channels: [1]);\
		b.plot;\
		b.free;\
		\
		\cf3 // Now reverse channel order\cf0 \
		b = \cf2 Buffer\cf0 .readChannel(s, \cf4 "sounds/SinedPink.aiff"\cf0 , channels: [1, 0]);\
		b.plot;\
		b.free;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	
\f0\b\fs24 *readNoUpdate(server, path, startFrame, numFrames, completionMessage, bufnum)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		As 
\f0\b *read
\f1\b0  above, but without the automatic update of instance variables. Call 
\f0\b updateInfo 
\f1\b0 (see below) to update the vars.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
		
\f0\b server 
\f1\b0  - The server on which to allocate the buffer.\
		
\f0\b path
\f1\b0  - A 
\f0\b String
\f1\b0  representing the path of the soundfile to be read.\
		
\f0\b startFrame
\f1\b0  - The first frame of the soundfile to read. The default is 0, which is the beginning of the file.\
		
\f0\b numFrames 
\f1\b0 - The number of frames to read. The default is -1, which will read the whole file.\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
		
\f0\b bufnum
\f1\b0  - An explicitly specified buffer number. Generally this is not needed.\
		\
		
\f3\fs18 \cf3 // with a completion message			\cf0 \
		s.boot;\
		(\
		\cf2 SynthDef\cf0 (\cf4 "help-Buffer"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum;\
			\cf2 Out\cf0 .ar( out,\
				\cf2 PlayBuf\cf0 .ar(1,bufnum,\cf2 BufRateScale\cf0 .kr(bufnum))\
			)\
		\}).send(s);\
		\
		y = \cf2 Synth\cf0 .basicNew(\cf4 "help-Buffer"\cf0 ); \cf3 // not sent yet\cf0 \
		b = \cf2 Buffer\cf0 .readNoUpdate(s,\cf4 "sounds/a11wlk01.wav"\cf0 , \
			completionMessage: \{ \cf2 arg\cf0  buffer;\
				\cf3 // synth add its s_new msg to follow \cf0 \
				\cf3 // after the buffer read completes\cf0 \
				y.newMsg(s,[\cf5 \\bufnum\cf0 ,buffer.bufnum],\cf5 \\addToTail\cf0 )\
			\});\
		)\
		\cf3 // note vars not accurate\cf0 \
		b.numFrames; \cf3 // nil\cf0 \
		b.updateInfo;\
		b.numFrames; \cf3 // 26977\cf0 \
		\cf3 // when done...\cf0 \
		y.free;\
		b.free;	\
	\

\f0\b\fs24 	*cueSoundFile(server, path, startFrame, numChannels, bufferSize, completionMessage)\

\f1\b0 	\
		Allocate a buffer and preload a soundfile for streaming in using 
\f0\b DiskIn
\f1\b0 .\
		\
		
\f0\b server 
\f1\b0  - The server on which to allocate the buffer.\
		
\f0\b path
\f1\b0  - A 
\f0\b String
\f1\b0  representing the path of the soundfile to be read.\
		
\f0\b startFrame
\f1\b0  - The frame of the soundfile that 
\f0\b DiskIn
\f1\b0  will start playing at.\
		
\f0\b numChannels
\f1\b0  - The number of channels in the soundfile.\
		
\f0\b bufferSize
\f1\b0  - This must be a multiple of  (2 * the server's block size). 32768 is the default and is suitable for most cases.\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\fs18 \cf0 		s.boot;\
		(\
		\cf2 SynthDef\cf0 (\cf4 "help-Buffer-cue"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum;\
			\cf2 Out\cf0 .ar(out,\
				\cf2 DiskIn\cf0 .ar( 1, bufnum )\
			)\
		\}).send(s);\
		)\
		\
		(\
		s.makeBundle(nil, \{\
			b = \cf2 Buffer\cf0 .cueSoundFile(s,\cf4 "sounds/a11wlk01-44_1.aiff"\cf0 , 0, 1);\
			y = \cf2 Synth\cf0 .new(\cf4 "help-Buffer-cue", \cf0 [\cf5 \\bufnum\cf0 ,b.bufnum], s);\
		\});\
		)\
		b.free; y.free;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	
\f0\b\fs24 *loadCollection(server, collection, numChannels, action)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Load a large collection into a buffer on the server. Returns a Buffer object. This is accomplished through writing the collection to a 
\f0\b SoundFile
\f1\b0  and loading it from there. For this reason this method will only work with a server on your local machine. For a remote server use 
\f0\b *sendCollection
\f1\b0 , below. The file is automatically deleted after loading. This allows for larger collections than 
\f0\b setn
\f1\b0 , below, and is in general the safest way to get a large collection into a buffer. The sample rate of the buffer will be the sample rate of the server on which it is created.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
		
\f0\b server 
\f1\b0  - The server on which to create the buffer.\
		
\f0\b collection
\f1\b0  - A subclass of 
\f0\b Collection
\f1\b0  (i.e. an 
\f0\b Array
\f1\b0 ) containing 
\f2\i only
\f1\i0  floats and integers. Multi-dimensional arrays will not work.\
		
\f0\b numChannels 
\f1\b0 - The number of channels that the buffer should have. Note that buffers interleave multichannel data. You are responsible for providing an interleaved collection if needed. Multi-dimensional arrays will not work.\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.\
		\
		
\f3\fs18 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		(\
		a = \cf2 FloatArray\cf0 .fill(44100 * 5.0, \{1.0.rand2\}); \cf3 // 5 seconds of noise\cf0 \
		b = \cf2 Buffer\cf0 .loadCollection(s, a);\
		)\
		\
		\cf3 // test it\cf0 \
		b.get(20000,\{\cf2 |msg|\cf0  (msg == a[20000]).postln\});\
		\cf3 // play it\cf0 \
		x = \{ \cf2 PlayBuf\cf0 .ar(1, b.bufnum, \cf2 BufRateScale\cf0 .kr(b.bufnum), loop: 0) * 0.5 \}.play;\
		b.free; x.free;\
		\
		\cf3 // interleave a multi-dimensional array\cf0 \
		(\
		l = \cf2 Signal\cf0 .sineFill(16384, \cf2 Array\cf0 .fill(200, \{0\}).add(1));\
		r = \cf2 Array\cf0 .fill(16384, \{1.0.rand2\});\
		m = [\cf2 Array\cf0 .newFrom(l), r]; \cf3 // a multi-dimensional array\cf0 \
		m = m.lace(32768); \cf3 // interleave the two collections \cf0 \
		b = \cf2 Buffer\cf0 .loadCollection(s, m, 2, \{\cf2 |buf|\cf0 \
			x = \{ \cf2 PlayBuf\cf0 .ar(2, buf.bufnum, \cf2 BufRateScale\cf0 .kr(buf.bufnum), loop: 1) * 0.5 \}.play;\
		\});\
		)\
		b.plot;\
		x.free; b.free;\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	
\f0\b\fs24 *sendCollection(server, collection, numChannels, wait, action)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Stream a large collection into a buffer on the server using multiple 
\f0\b setn
\f1\b0  messages. Returns a Buffer object. This allows for larger collections than 
\f0\b setn
\f1\b0 , below. This is not as safe as 
\f0\b *loadCollection
\f1\b0 , above, but will work with servers on remote machines. The sample rate of the buffer will be the sample rate of the server on which it is created.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
		
\f0\b server 
\f1\b0  - The server on which to create the buffer.\
		
\f0\b collection
\f1\b0  - A subclass of 
\f0\b Collection
\f1\b0  (i.e. an 
\f0\b Array
\f1\b0 ) containing 
\f2\i only
\f1\i0  floats and integers. Multi-dimensional arrays will not work.\
		
\f0\b numChannels 
\f1\b0 - The number of channels that the buffer should have. Note that buffers interleave multichannel data. You are responsible for providing an interleaved collection if needed. Multi-dimensional arrays will not work. See the example in 
\f0\b *loadCollection
\f1\b0 , above, to see how to do this.\
		
\f0\b wait
\f1\b0  - An optional wait time between sending 
\f0\b setn
\f1\b0  messages. In a high traffic situation it may be safer to set this to something above zero, which is the default.\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.\
		\
		
\f3\fs18 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		(\
		a = \cf2 Array\cf0 .fill(2000000,\{ rrand(0.0,1.0) \}); \cf3 // a LARGE collection\cf0 \
		b = \cf2 Buffer\cf0 .sendCollection(s, a, 1, 0, \{\cf2 arg\cf0  buf; \cf4 "finished"\cf0 .postln;\});\
		)\
		b.get(1999999, \{\cf2 |msg|\cf0  (msg == a[1999999]).postln\});\
		b.free;\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	
\f0\b\fs24 *loadDialog(server, path, startFrame, numFrames, bufnum)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		As 
\f0\b *read
\f1\b0  above, but gives you a load dialog window to browse for a file. OSX only.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
		
\f0\b server 
\f1\b0  - The server on which to allocate the buffer.\
		
\f0\b startFrame
\f1\b0  - The first frame of the soundfile to read. The default is 0, which is the beginning of the file.\
		
\f0\b numFrames 
\f1\b0 - The number of frames to read. The default is -1, which will read the whole file.\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.\
		
\f0\b bufnum
\f1\b0  - An explicitly specified buffer number. Generally this is not needed.
\f0\b \
		\
	
\f3\b0\fs18 	s.boot;\
		(\
		b = \cf2 Buffer\cf0 .loadDialog(s, action: \{ \cf2 arg\cf0  buffer; \
			x = \{ \cf2 PlayBuf\cf0 .ar(b.numChannels, buffer.bufnum, \cf2 BufRateScale\cf0 .kr(buffer.bufnum)) \}.play;\
		\});\
		)\
		x.free; b.free;
\f0\b\fs24 \
		
\f3\b0\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Creation without Immediate Memory Allocation\ul \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\fs24 \cf0 \ulnone 	*new(server, numFrames, numChannels, bufnum)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\b0\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\fs24 \cf0 		Create and return a new Buffer object, without immediately allocating the corresponding memory on the server. This combined with 'message' methods can be flexible with bundles.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
		
\f0\b server 
\f1\b0  - The server on which to allocate the buffer. The default is the default 
\f0\b Server
\f1\b0 .\
		
\f0\b numFrames 
\f1\b0 - The number of frames to allocate. Actual memory use will correspond to numFrames * numChannels.\
		
\f0\b numChannels
\f1\b0  - The number of channels for the Buffer. The default is 1.\
		
\f0\b bufnum
\f1\b0  - An explicitly specified buffer number. Generally this is not needed.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\fs18 \cf0 	\
		s.boot;\
		b = \cf2 Buffer\cf0 .new(s, 44100 * 8.0, 2);\
		c = \cf2 Buffer\cf0 .new(s, 44100 * 4.0, 2);\
		b.query; \cf3 // numFrames = 0\cf0 \
		s.sendBundle(nil, b.allocMsg, c.allocMsg); \cf3 // sent both at the same time\cf0 \
		b.query; \cf3 // now it's right\cf0 \
		c.query;\
		b.free; c.free;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\
	
\f0\b alloc(completionMessage)\
	allocMsg(completionMessage)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\b0\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\fs24 \cf0 		Allocate the necessary memory on the server for a Buffer previously created with 
\f0\b *new
\f1\b0 , above.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
	\
		
\f3\fs18 s.boot;\
		b = \cf2 Buffer\cf0 .new(s, 44100 * 8.0, 2);\
		b.query; \cf3 // numFrames = 0\cf0 \
		b.alloc;\
		b.query; \cf3 // numFrames = 352800\cf0 \
		b.free;
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	
\f0\b allocRead(argpath, startFrame, numFrames, completionMessage)\
	allocReadMsg(argpath, startFrame, numFrames, completionMessage)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\b0\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\fs24 \cf0 		Read a soundfile into a buffer on the server for a Buffer previously created with 
\f0\b *new
\f1\b0 , above. Note that this will not autoupdate instance variables. Call 
\f0\b updateInfo
\f1\b0  in order to do this.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 \

\f0\b 		argpath
\f1\b0  - A 
\f0\b String
\f1\b0  representing the path of the soundfile to be read.\
		
\f0\b startFrame
\f1\b0  - The first frame of the soundfile to read. The default is 0, which is the beginning of the file.\
		
\f0\b numFrames 
\f1\b0 - The number of frames to read. The default is -1, which will read the whole file.\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
		\
		
\f3\fs18 s.boot;\
		b = \cf2 Buffer\cf0 .new(s);\
		b.allocRead(\cf4 "sounds/a11wlk01.wav"\cf0 );\
		x = \{ \cf2 PlayBuf\cf0 .ar(1, b.bufnum, \cf2 BufRateScale\cf0 .kr(b.bufnum), loop: 1) * 0.5 \}.play;\
		x.free; b.free;
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	
\f0\b allocReadChannel(argpath, startFrame, numFrames, channels, completionMessage)\
	allocReadChannelMsg(argpath, startFrame, numFrames, channels, completionMessage)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\b0\fs18 \cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\fs24 \cf0 		As 
\f0\b allocRead
\f1\b0  above, but allows you to specify which channels to read.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 \

\f0\b 		argpath
\f1\b0  - A 
\f0\b String
\f1\b0  representing the path of the soundfile to be read.\
		
\f0\b startFrame
\f1\b0  - The first frame of the soundfile to read. The default is 0, which is the beginning of the file.\
		
\f0\b numFrames 
\f1\b0 - The number of frames to read. The default is -1, which will read the whole file.\
		
\f0\b channels
\f1\b0  - An 
\f0\b Array
\f1\b0  of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided.\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
		\
		
\f3\fs18 s.boot;\
		b = \cf2 Buffer\cf0 .new(s);\
		\cf3 // read only the first channel (a Sine wave) of a stereo file\cf0 \
		b.allocReadChannel(\cf4 "sounds/SinedPink.aiff"\cf0 , channels: [0]);\
		x = \{ \cf2 PlayBuf\cf0 .ar(1, b.bufnum, \cf2 BufRateScale\cf0 .kr(b.bufnum), loop: 1) * 0.5 \}.play;\
		x.free; b.free;
\f1\fs24 		\
		
\f0\b\fs28 \ul \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 \ulnone Instance Methods
\f1\b0\fs24 \
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f0\b \cf0 	read(path, fileStartFrame, numFrames, bufStartFrame, leaveOpen, action);\

\f1\b0 	
\f0\b readMsg(path, fileStartFrame, numFrames, bufStartFrame, leaveOpen, completionMessage);\

\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Read a soundfile into an already allocated buffer. Note that if the number of frames in the file is greater than the number of frames in the buffer, it will be truncated. Note that 
\f0\b readMsg
\f1\b0  will not auto-update instance variables. Call 
\f0\b updateInfo 
\f1\b0 in order to do this.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\

\f0\b 		path
\f1\b0  - A 
\f0\b String
\f1\b0  representing the path of the soundfile to be read.\
		
\f0\b fileStartFrame
\f1\b0  - The first frame of the soundfile to read. The default is 0, which is the beginning of the file.\
		
\f0\b numFrames 
\f1\b0 - The number of frames to read. The default is -1, which will read the whole file.\
		
\f0\b bufStartFrame
\f1\b0  - The index of the frame in the buffer at which to start reading. The default is 0, which is the beginning of the buffer.\
		
\f0\b leaveOpen
\f1\b0  - A boolean indicating whether or not the Buffer should be left 'open'. For use with 
\f0\b DiskIn
\f1\b0  you will want this to be true, as the buffer will be used for streaming the soundfile in from disk. (For this the buffer must have been allocated with a multiple of (2 * synth block size).  A common number is 32768 frames. 
\f0\b cueSoundFile
\f1\b0  below, provides a simpler way of doing this.) The default is false which is the correct value for all other cases.\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
		\

\f0\b 	readChannel(path, fileStartFrame, numFrames, bufStartFrame, leaveOpen, channels, action);\

\f1\b0 	
\f0\b readChannelMsg(path, fileStartFrame, numFrames, bufStartFrame, leaveOpen, channels, completionMessage);\

\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		As 
\f0\b read
\f1\b0  above, but allows you to specify which channels to read.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\

\f0\b 		path
\f1\b0  - A 
\f0\b String
\f1\b0  representing the path of the soundfile to be read.\
		
\f0\b fileStartFrame
\f1\b0  - The first frame of the soundfile to read. The default is 0, which is the beginning of the file.\
		
\f0\b numFrames 
\f1\b0 - The number of frames to read. The default is -1, which will read the whole file.\
		
\f0\b bufStartFrame
\f1\b0  - The index of the frame in the buffer at which to start reading. The default is 0, which is the beginning of the buffer.\
		
\f0\b leaveOpen
\f1\b0  - A boolean indicating whether or not the Buffer should be left 'open'. For use with 
\f0\b DiskIn
\f1\b0  you will want this to be true, as the buffer will be used for streaming the soundfile in from disk. (For this the buffer must have been allocated with a multiple of (2 * synth block size).  A common number is 32768 frames. 
\f0\b cueSoundFile
\f1\b0  below, provides a simpler way of doing this.) The default is false which is the correct value for all other cases.\
		
\f0\b channels
\f1\b0  - An 
\f0\b Array
\f1\b0  of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided. The number of channels requested must match this Buffer's 
\f0\b numChannels
\f1\b0 .\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
	
\f0\b 	\

\f1\b0 \

\f0\b 	cueSoundFile(path, startFrame, completionMessage)\

\f1\b0 	
\f0\b cueSoundFileMsg(path, startFrame, completionMessage)\

\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		A convenience method to cue a soundfile into the buffer for use with a 
\f0\b DiskIn
\f1\b0 . The buffer must have been allocated with a multiple of (2 * the server's block size) frames.  A common size is 32768 frames.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b path
\f1\b0  - A 
\f0\b String
\f1\b0  representing the path of the soundfile to be read.\
		
\f0\b startFrame
\f1\b0  - The first frame of the soundfile to read. The default is 0, which is the beginning of the file.\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
		\
		
\f3\fs18 s.boot;
\f1\fs24 \
		
\f3\fs18 \cf3 //create with cueSoundFile class method\cf0 \
		b = \cf2 Buffer\cf0 .cueSoundFile(s, \cf4 "sounds/a11wlk01-44_1.aiff"\cf0 , 0, 1);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		x = \{ \cf2 DiskIn\cf0 .ar(1, b.bufnum) \}.play;	\
		b.close;	\cf3 // must call close in between cueing\cf0 \
		\cf3 // now use like named instance method, but different arguments\cf0 \
		b.cueSoundFile(\cf4 "sounds/a11wlk01-44_1.aiff"\cf0 );	\
		\cf3 // have to do all this to clean up properly!	\cf0 \
		x.free; b.close; b.free;	
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	
\f0\b \
	write(path, headerFormat, sampleFormat, numFrames, startFrame, leaveOpen, completionMessage)\
	writeMsg(path, headerFormat, sampleFormat, numFrames, startFrame, leaveOpen, completionMessage)\

\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Write the contents of the buffer to a file. See 
\f0\b SoundFile
\f1\b0  for information on valid values for 
\f0\b headerFormat
\f1\b0  and 
\f0\b sampleFormat
\f1\b0 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b path
\f1\b0  - A 
\f0\b String
\f1\b0  representing the path of the soundfile to be written.\
		
\f0\b numFrames 
\f1\b0 - The number of frames to write. The default is -1, which will write the whole buffer.\
		
\f0\b startFrame
\f1\b0  - The index of the frame in the buffer from which to start writing. The default is 0, which is the beginning of the buffer.\
		
\f0\b leaveOpen
\f1\b0  - A boolean indicating whether or not the Buffer should be left 'open'. For use with 
\f0\b DiskOut
\f1\b0  you will want this to be true. The default is false which is the correct value for all other cases.\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
\

\f0\b 	free(completionMessage)
\f1\b0 \

\f0\b 	freeMsg(completionMessage)
\f1\b0 \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Release the buffer's memory on the server and return the bufferID back to the server's buffer number allocator for future reuse.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
\

\f0\b 	zero(completionMessage)
\f1\b0 \
	
\f0\b zeroMsg(completionMessage)
\f1\b0 \
	\
		Sets all values in this buffer to 0.0.\
		\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
		\

\f0\b 	set(index,float ... morePairs)\
	setMsg(index,float ... morePairs)\

\f1\b0 		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Set the value in the buffer at 
\f0\b index
\f1\b0  to be equal to 
\f0\b float
\f1\b0 . Additional pairs of indices and floats may be included in the same message. Note that multichannel buffers interleave their sample data, therefore the actual number of available values is equal to numFrames * numChannels. Indices start at 0.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\fs18 \cf0 		s.boot;\
		b = \cf2 Buffer\cf0 .alloc(s, 4, 2);\
		b.set(0, 0.2, 1, 0.3, 7, 0.4); \cf3 // set the values at indices 0, 1, and 7.\cf0 \
		b.getn(0, 8, \{\cf2 |msg|\cf0  msg.postln\});\
		b.free;	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f1\fs24 \cf0 \

\f0\b 	setn(startAt,values ... morePairs)\
	setnMsg(startAt,values ... morePairs)\

\f1\b0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Set a contiguous range of values in the buffer starting at the index 
\f0\b startAt
\f1\b0  to be equal to the 
\f0\b Array
\f1\b0  of floats or integers, 
\f0\b values
\f1\b0 . The number of values set corresponds to the size of 
\f0\b values
\f1\b0 . Additional pairs of starting indices and arrays of values may be included in the same message. Note that multichannel buffers interleave their sample data, therefore the actual number of available values is equal to numFrames * numChannels. You are responsible for interleaving the data in 
\f0\b values
\f1\b0  if needed. Multi-dimensional arrays will not work. Indices start at 0.\
		\
		
\f0\b N.B.
\f1\b0  The maximum number of values that you can set with a single setn message is 1633 when the server is using UDP as its communication protocol. Use 
\f0\b loadCollection
\f1\b0  and 
\f0\b sendCollection
\f1\b0  to set larger ranges of values.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\fs18 \cf0 \
		s.boot;\
		b = \cf2 Buffer\cf0 .alloc(s,16);\
		b.setn(0, \cf2 Array\cf0 .fill(16, \{ rrand(0,1) \}));\
		b.getn(0, b.numFrames, \{\cf2 |msg|\cf0  msg.postln\});\
		b.setn(0, [1, 2, 3], 4, [1, 2, 3]);\
		b.getn(0, b.numFrames, \{\cf2 |msg|\cf0  msg.postln\});\
		b.free;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 \
	
\f0\b\fs24 loadCollection(collection, startFrame, action)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Load a large collection into this buffer. This is accomplished through writing the collection to a 
\f0\b SoundFile
\f1\b0  and loading it from there. For this reason this method will only work with a server on your local machine. For a remote server use 
\f0\b sendCollection
\f1\b0 , below. The file is automatically deleted after loading. This allows for larger collections than 
\f0\b setn
\f1\b0 , above, and is in general the safest way to get a large collection into a buffer. The sample rate of the buffer will be the sample rate of the server on which it was created. The number of channels and frames will have been determined when the buffer was allocated. You are responsible for making sure that the size of 
\f0\b collection
\f1\b0  is not greater than 
\f0\b numFrames
\f1\b0 , and for interleaving any data if needed. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
		
\f0\b collection
\f1\b0  - A subclass of 
\f0\b Collection
\f1\b0  (i.e. an 
\f0\b Array
\f1\b0 ) containing 
\f2\i only
\f1\i0  floats and integers. Multi-dimensional arrays will not work.\
		
\f0\b startFrame 
\f1\b0 - The index of the frame at which to start loading the collection. The default is 0, which is the start of the buffer.\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.\
		\
		
\f3\fs18 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		(\
		v = \cf2 Signal\cf0 .sineFill(128, 1.0/[1,2,3,4,5,6]);\
		b = \cf2 Buffer\cf0 .alloc(s, 128);\
		)\
		(\
		b.loadCollection(v, action: \{|buf| \
			x = \{ \cf2 PlayBuf\cf0 .ar(buf.numChannels, buf.bufnum, \cf2 BufRateScale\cf0 .kr(buf.bufnum), loop: 1) \
				* 0.2 \}.play;\
		\});\
		)\
		x.free; b.free;\
				\
		\cf3 // interleave a multi-dimensional array\cf0 \
		(\
		l = \cf2 Signal\cf0 .sineFill(16384, \cf2 Array\cf0 .fill(200, \{0\}).add(1));\
		r = \cf2 Array\cf0 .fill(16384, \{1.0.rand2\});\
		m = [\cf2 Array\cf0 .newFrom(l), r]; \cf3 // a multi-dimensional array\cf0 \
		m = m.lace(32768); \cf3 // interleave the two collections \
		\cf0 b = \cf2 Buffer\cf0 .alloc(s, 16384, 2);\
		)\
		(\
		b.loadCollection(m, 0, \{\cf2 |buf|\cf0 \
			x = \{ \cf2 PlayBuf\cf0 .ar(2, buf.bufnum, \cf2 BufRateScale\cf0 .kr(buf.bufnum), loop: 1) * 0.5 \}.play;\
		\});\
		)\
		b.plot;\
		x.free; b.free;\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	
\f0\b\fs24 sendCollection(collection, startFrame, wait, action)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Stream a large collection into this buffer using multiple 
\f0\b setn
\f1\b0  messages. This allows for larger collections than 
\f0\b setn
\f1\b0 . This is not as safe as 
\f0\b loadCollection
\f1\b0 , above, but will work with servers on remote machines. The sample rate of the buffer will be the sample rate of the server on which it is created.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
		
\f0\b collection
\f1\b0  - A subclass of 
\f0\b Collection
\f1\b0  (i.e. an 
\f0\b Array
\f1\b0 ) containing 
\f2\i only
\f1\i0  floats and integers. Multi-dimensional arrays will not work.\
		
\f0\b startFrame 
\f1\b0 - The index of the frame at which to start streaming in the collection. The default is 0, which is the start of the buffer.\
		
\f0\b wait
\f1\b0  - An optional wait time between sending 
\f0\b setn
\f1\b0  messages. In a high traffic situation it may be safer to set this to something above zero, which is the default.\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf0 		s.boot;\
		(\
		a = \cf2 Array\cf0 .fill(2000000,\{ rrand(0.0,1.0) \});\
		b = \cf2 Buffer\cf0 .alloc(s, 2000000);\
		)\
		b = b.sendCollection(a, action: \{\cf2 arg\cf0  buf; \cf4 "finished"\cf0 .postln;\});\
		b.get(1999999, \{\cf2 |msg|\cf0  (msg == a[1999999]).postln\});\
		b.free;\
		
\f0\b\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	get(index, action)\
	getMsg(index)
\f1\b0 \

\f0\b \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Send a message requesting the value in the buffer at 
\f0\b index
\f1\b0 . 
\f0\b action
\f1\b0  is a 
\f0\b Function
\f1\b0  which will be passed the value as an argument and evaluated when a reply is received.\
		\
		
\f3\fs18 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		b = \cf2 Buffer\cf0 .alloc(s,16);\
		b.setn(0, \cf2 Array\cf0 .fill(16, \{ rrand(0.0, 1.0) \}));\
		b.get(0, \{\cf2 |msg|\cf0  msg.postln\});\
		b.free;
\f0\b\fs24 \
\
	getn(index, count, action)\
	getMsg(index, count)
\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f0\b \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Send a message requesting the a contiguous range of values of size 
\f0\b count
\f1\b0  starting from 
\f0\b index
\f1\b0 . 
\f0\b action
\f1\b0  is a 
\f0\b Function
\f1\b0  which will be passed the values in an 
\f0\b Array
\f1\b0  as an argument and evaluated when a reply is received. See 
\f0\b setn
\f1\b0  above for an example. \
		\
		
\f0\b N.B.
\f1\b0  The maximum number of values that you can get with a single getn message is 1633 when the server is using UDP as its communication protocol. Use 
\f0\b loadToFloatArray
\f1\b0  and 
\f0\b getToFloatArray
\f1\b0  to get larger ranges of values.\
	\
	
\f0\b loadToFloatArray(index, count, action)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Write the buffer to a file and then load it into a 
\f0\b FloatArray
\f1\b0 . This is safer than 
\f0\b getToFloatArray
\f1\b0  but only works with a server on your local machine. In general this is the safest way to get a large range of values from a server buffer into the client app.\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		
\f0\b index
\f1\b0  - The index in the buffer to begin writing from. The default is 0.\
		
\f0\b count
\f1\b0  - The number of values to write. The default is -1, which writes from index until the end of the  buffer.\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  which will be passed the resulting 
\f0\b FloatArray
\f1\b0  as an argument and evaluated when loading is finished.\
		\
		
\f3\fs18 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		b = \cf2 Buffer\cf0 .read(s,\cf4 "sounds/a11wlk01.wav"\cf0 );\
		\cf3 // same as Buffer.plot\cf0 \
		b.loadToFloatArray(action: \{ \cf2 arg\cf0  array; a = array; \{a.plot;\}.defer; \cf4 "done"\cf0 .postln;\});\
		b.free;
\f0\b\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 \
	
\f0\b getToFloatArray(index, count, wait, timeout, action)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Stream the buffer to the client using a series of 
\f0\b getn
\f1\b0  messages and put the results into a 
\f0\b FloatArray
\f1\b0 . This is more risky than 
\f0\b loadToFloatArray
\f1\b0  but does works with servers on remote machines. In high traffic situations it is possible for data to be lost. If this method has not received all its replies by 
\f0\b timeout
\f1\b0  it will post a warning saying that the method has failed. In general use 
\f0\b loadToFloatArray
\f1\b0  instead wherever possible.\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		
\f0\b index
\f1\b0  - The index in the buffer to begin writing from. The default is 0.\
		
\f0\b count
\f1\b0  - The number of values to write. The default is -1, which writes from index until the end of the  buffer.\
		
\f0\b wait
\f1\b0  - The amount of time in seconds to wait between sending getn messages. Longer times are safer. The default is 0.01 seconds which seems reliable under normal circumstances. A setting of 0 is 
\f2\i not
\f0\i0\b  
\f1\b0 recommended.\
		
\f0\b timeout
\f1\b0  - The amount of time in seconds after which to post a warning if all replies have not yet been received. the default is 3.\
		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  which will be passed the resulting 
\f0\b FloatArray
\f1\b0  as an argument and evaluated when all replies have been received.\
\
		
\f3\fs18 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		b = \cf2 Buffer\cf0 .read(s,\cf4 "sounds/a11wlk01.wav"\cf0 );\
		\cf3 // like Buffer.plot\cf0 \
		b.getToFloatArray(wait:0.01,action:\{arg array; a = array; \{a.plot;\}.defer;"done".postln;\});\
		b.free;\
		
\f1\fs24 		
\f0\b 	
\f1\b0 	
\f0\b 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	fill(startAt, numFrames, value ... more)\
	fillMsg(startAt, numFrames, value ... more)\

\f1\b0 		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Starting at the index 
\f0\b startAt
\f1\b0 , set the next 
\f0\b numFrames
\f1\b0  to value. Additional ranges may be included in the same message.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\

\f0\b 	copy(buf, dstStartAt, srcStartAt, numSamples)\
	copyMsg(buf, dstStartAt, srcStartAt, numSamples)\

\f1\b0 		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 		Starting at the index 
\f0\b srcSamplePos
\f1\b0 , copy 
\f0\b numSamples
\f1\b0  samples from this to the destination buffer 
\f0\b buf
\f1\b0  starting at 
\f0\b dstSamplePos
\f1\b0 . If numSamples is negative, the maximum number of samples possible is copied. The default is start from 0 in the source and copy the maximum number possible starting at 0 in the destination.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 \
		
\f3\fs18 s.boot;\
		(\
		\cf2 SynthDef\cf0 (\cf4 "help-Buffer-copy"\cf0 , \{ \cf2 arg\cf0  out=0, buf;\
			\cf2 Line\cf0 .ar(0, 0, dur: \cf2 BufDur\cf0 .kr(buf), doneAction: 2); \cf3 // frees itself\cf0 \
			\cf2 Out\cf0 .ar(out, \cf2 PlayBuf\cf0 .ar(1, buf, 0.25));\
		\}).send(s);\
		)\
		\
		(\
		b = \cf2 Buffer\cf0 .read(s, \cf4 "sounds/a11wlk01.wav"\cf0 );\
		c = \cf2 Buffer\cf0 .alloc(s, 120000);\
		)\
\
		\cf2 Synth\cf0 (\cf4 "help-Buffer-copy"\cf0 , [\cf5 \\buf\cf0 , b.bufnum]);		\
		\
		\cf3 // copy the whole buffer\cf0 \
		b.copy(c);\
		\cf2 Synth\cf0 (\cf4 "help-Buffer-copy"\cf0 , [\cf5 \\buf\cf0 , c.bufnum]);\
		\
		\cf3 // copy some samples\cf0 \
		c.zero;								\
		b.copy(c, numSamples: 4410);\
		\cf2 Synth\cf0 (\cf4 "help-Buffer-copy"\cf0 , [\cf5 \\buf\cf0 , c.bufnum]);\
		\
		\cf3 // buffer "compositing"\cf0 \
		c.zero;								\
		b.copy(c, numSamples: 4410);\
		b.copy(c, dstStartAt: 4410, numSamples: 15500);\
		\cf2 Synth\cf0 (\cf4 "help-Buffer-copy"\cf0 , [\cf5 \\buf\cf0 , c.bufnum]);\

\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f3\fs18 \cf0 		b.free;\
		c.free;
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f0\b \cf0 	close(completionMessage)\
	closeMsg(completionMessage)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		After using a Buffer with a 
\f0\b DiskOut
\f1\b0  or 
\f0\b DiskIn
\f1\b0 , it is necessary to close the soundfile. Failure to do so can cause problems.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b completionMessage 
\f1\b0 - A valid OSC message or a 
\f0\b Function
\f1\b0  which will return one. A Function will be passed this Buffer as an argument when evaluated.\
	
\f3\fs18 \

\f0\b\fs24 	plot(name, bounds, minval = -1.0, maxval = 1.0, parent)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Plot the contents of the Buffer in a GUI window. OSX only.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b name 
\f1\b0 - The name of the resulting window.\
		
\f0\b bounds
\f1\b0  - An instance of 
\f0\b Rect
\f1\b0  determining the size of the resulting view.\
		
\f0\b minval
\f1\b0  - the minimum value in the plot\
		
\f0\b maxval
\f1\b0  - the maximum value in the plot\
		
\f0\b parent
\f1\b0  - a window to place the plot in. If nil, one will be created for you\
		\
		
\f3\fs18 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		b = \cf2 Buffer\cf0 .read(s,\cf4 "sounds/a11wlk01.wav"\cf0 );\
		b.plot;\
		b.free;\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f0\b\fs24 \cf0 	play(loop, mul)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Plays the contents of the buffer on the server and returns a corresponding 
\f0\b Synth
\f1\b0 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b loop 
\f1\b0 - A Boolean indicating whether or not to loop playback. If false the synth will automatically be freed when done. The default is false.\
		
\f0\b mul
\f1\b0  - A value by which to scale the output. The default is 1.\
		\
		
\f3\fs18 s.boot;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		b = \cf2 Buffer\cf0 .read(s,\cf4 "sounds/a11wlk01.wav"\cf0 );\
		b.play; \cf3 // frees itself\cf0 \
		x = b.play(\cf2 true\cf0 );\
		x.free; b.free;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f0\b\fs24 \cf0 	query\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Sends a b_query message to the server, asking for a description of this buffer. The results are posted to the post window. Does not update instance vars.\
		\
	
\f0\b updateInfo(action)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Sends a b_query message to the server, asking for a description of this buffer. Upon reply this Buffer's instance variables are automatically updated.\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		
\f0\b action
\f1\b0  - A 
\f0\b Function
\f1\b0  to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.\
		\
		
\f3\fs18 s.boot;\
		b = \cf2 Buffer\cf0 .readNoUpdate(s, \cf4 "sounds/a11wlk01.wav"\cf0 );\
		b.numFrames; \cf3 // incorrect, shows nil\cf0 \
		b.updateInfo(\{\cf2 |buf|\cf0  buf.numFrames.postln; \}); \cf3 // now it's right\cf0 \
		b.free;\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Buffer Fill Commands
\f3\b0\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 These correspond to the various b_gen OSC Commands, which fill the buffer with values for use. See 
\f0\b Server-Command-Reference
\f1\b0  for more details.
\f3\fs18 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f0\b\fs24 \cf0 	gen(genCommand, genArgs, normalize, asWaveTable, clearFirst)\
	genMsg(genCommand, genArgs, normalize, asWaveTable, clearFirst)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		This is a generalized version of the commands below.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b genCommand 
\f1\b0 - A 
\f0\b String
\f1\b0  indicating the name of the command to use. See 
\f0\b Server-Command-Reference
\f1\b0  for a list of valid command names.\
		
\f0\b genArgs
\f1\b0  - An 
\f0\b Array
\f1\b0  containing the corresponding arguments to the command.\
		
\f0\b normalize
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.\
		
\f0\b asWaveTable
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.\
		
\f0\b clearFirst
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to clear the buffer before writing. The default is true.\
		\

\f0\b 	sine1(amps, normalize, asWaveTable, clearFirst)\
	sine1Msg(amps, normalize, asWaveTable, clearFirst)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Fill this buffer with a series of sine wave harmonics using specified amplitudes.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b amps
\f1\b0  - An 
\f0\b Array 
\f1\b0 containing amplitudes for the harmonics. The first float value specifies the amplitude of the first partial, the second float value specifies the amplitude of the second partial, and so on.\
		
\f0\b normalize
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.\
		
\f0\b asWaveTable
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.\
		
\f0\b clearFirst
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to clear the buffer before writing. The default is true.\
		\
		
\f3\fs18 s.boot;\
		(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		b = \cf2 Buffer\cf0 .alloc(s, 512, 1);\
		b.sine1(1.0/[1,2,3,4], \cf2 true\cf0 , \cf2 true\cf0 , \cf2 true\cf0 );\
		\
		x = \cf2 SynthDef\cf0 (\cf4 "help-Osc"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum=0;\
			\cf2 Out\cf0 .ar(out,\
				\cf2 Osc\cf0 .ar(bufnum, 200, 0, 0.5)\
			)\
		\}).play(s,[\cf5 \\out\cf0 , 0, \cf5 \\bufnum\cf0 , b.bufnum]);\
		)\
		x.free; b.free;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\

\f0\b 	sine2(freqs, amps, normalize, asWaveTable, clearFirst)\
	sine2Msg(freqs, amps, normalize, asWaveTable, clearFirst)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Fill this buffer with a series of sine wave partials using specified frequencies and amplitudes.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b freqs
\f1\b0  - An 
\f0\b Array 
\f1\b0 containing frequencies (in cycles per buffer) for the partials.\
		
\f0\b amps
\f1\b0  - An 
\f0\b Array 
\f1\b0 containing amplitudes for the partials. This should contain the same number of items as freqs.\
		
\f0\b normalize
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.\
		
\f0\b asWaveTable
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.\
		
\f0\b clearFirst
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to clear the buffer before writing. The default is true.\
		\
		
\f3\fs18 s.boot;\
		(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 		b = \cf2 Buffer\cf0 .alloc(s, 512, 1);\
		b.sine2([1.0, 3], [1, 0.5]);\
		\
		x = \cf2 SynthDef\cf0 (\cf4 "help-Osc"\cf0 ,\{ \cf2 arg\cf0  out=0,bufnum=0;\
			\cf2 Out\cf0 .ar(out,\
				\cf2 Osc\cf0 .ar(bufnum, 440, 0, 0.5)\
			)\
		\}).play(s,[\cf5 \\out\cf0 , 0, \cf5 \\bufnum\cf0 , b.bufnum]);\
		)\
		x.free; b.free;
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\

\f0\b 	sine3(freqs, amps, phases, normalize, asWaveTable, clearFirst)\
	sine3Msg(freqs, amps, phases, normalize, asWaveTable, clearFirst)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Fill this buffer with a series of sine wave partials using specified frequencies, amplitudes, and initial phases.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b freqs
\f1\b0  - An 
\f0\b Array 
\f1\b0 containing frequencies (in cycles per buffer) for the partials.\
		
\f0\b amps
\f1\b0  - An 
\f0\b Array 
\f1\b0 containing amplitudes for the partials. This should contain the same number of items as freqs.\
		
\f0\b phases
\f1\b0  - An 
\f0\b Array 
\f1\b0 containing initial phase for the partials (in radians). This should contain the same number of items as freqs.\
		
\f0\b normalize
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.\
		
\f0\b asWaveTable
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.\
		
\f0\b clearFirst
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to clear the buffer before writing. The default is true.
\f3\fs18 \
\
\

\f0\b\fs24 	cheby(amplitudes, normalize, asWaveTable, clearFirst)\
	chebyMsg(amplitudes, normalize, asWaveTable, clearFirst)\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural

\f1\b0 \cf0 		Fill this buffer with a series of chebyshev polynomials, which can be defined as: cheby(n) = amplitude  * cos(n * acos(x)). To eliminate a DC offset when used as a waveshaper, the wavetable is offset so that the center value is zero. \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 		\
		
\f0\b amplitudes
\f1\b0  - An 
\f0\b Array 
\f1\b0 containing amplitudes for the harmonics. The first float value specifies the amplitude for n = 1, the second float value specifies the amplitude for n = 2, and so on.\
		
\f0\b normalize
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.\
		
\f0\b asWaveTable
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.\
		
\f0\b clearFirst
\f1\b0  - A 
\f0\b Boolean
\f1\b0  indicating whether or not to clear the buffer before writing. The default is true.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\fs18 \cf0 		s.boot;\
		b = \cf2 Buffer\cf0 .alloc(s, 512, 1, \{\cf2 arg\cf0  buf; buf.chebyMsg([1,0,1,1,0,1])\});\
		(\
		x = play(\{ \
			\cf2 Shaper\cf0 .ar(\
				b.bufnum, \
				\cf2 SinOsc\cf0 .ar(300, 0, \cf2 Line\cf0 .kr(0,1,6)),\
				0.5\
			) \
		\});\
		)\
		x.free; b.free;
\f1\fs24 	}