{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fnil\fcharset77 Monaco;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;\red0\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 Env						
\fs24 envelope specification
\f1\b0 \
\

\f0\b superclass: Object\

\f1\b0 \
An Env is a specification for a segmented envelope. Envs can be used both server-side, by an 
\f0\b EnvGen 
\f1\b0 within a SynthDef, and clientside, with methods such as 
\f0\b at
\f1\b0  and 
\f0\b asStream
\f1\b0 , below. An Env can have any number of segments which can stop at a particular value or loop several segments when sustaining. An Env can have several shapes for its segments.\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Basic Creation
\f1\b0\fs24 \
\
*
\f0\b new(levels, times, curves, releaseNode, loopNode)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
	Create a new envelope specification.\
	
\f0\b levels
\f1\b0  - an array of levels. The first level is the initial value of the envelope.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1120\fi-1120\ql\qnatural
\cf0 	
\f0\b times
\f1\b0  - an array of durations of segments in seconds. There should be one fewer duration than there are levels.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	
\f0\b curve
\f1\b0  - this parameter determines the shape of the envelope segments.\
	The possible values are:\
		'step' - flat segments\
		'linear' - linear segments, the default\
		'exponential' - natural exponential growth and decay. In this case, the levels must all be nonzero\
					and the have the same sign.\
		'sine' - sinusoidal S shaped segments.\
		'welch' - sinusoidal segments shaped like the sides of a Welch window.\
		a Float - a curvature value for all segments.\
		An Array of Floats - curvature values for each segments.\
	
\f0\b releaseNode
\f1\b0  - an Integer or nil. The envelope will sustain at the release node until released.\
	
\f0\b loopNode
\f1\b0  - an Integer or nil. If not nil the sustain portion will loop from the releaseNode to the loop node.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf2 		\cf0 s.boot;
\fs24 \
		
\fs18 \cf2 // different shaped segments:\cf0 \
		\cf3 Env\cf0 .new([0,1, 0.3, 0.8, 0], [2, 3, 1, 4],\cf4 'linear'\cf0 ).test.plot;\
		\cf3 Env\cf0 .new([0.001, 1, 0.3, 0.8, 0.001], [2, 3, 1, 4],\cf4 'exponential'\cf0 ).test.plot;\
		\cf3 Env\cf0 .new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4],\cf4 'sine'\cf0 ).test.plot;\
		\cf3 Env\cf0 .new([0.001, 1, 0.3, 0.8, 0.001],[2,3,1,4],\cf4 'welch'\cf0 ).test.plot;\
		\cf3 Env\cf0 .new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4],\cf4 'step'\cf0 ).test.plot;\
		\cf3 Env\cf0 .new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], -2).test.plot;\
		\cf3 Env\cf0 .new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], 2).test.plot;\
		\cf3 Env\cf0 .new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], [0, 3, -3, -1]).test.plot;\
		\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs24 \cf0 If a release node is given, and the gate input of the EnvGen is set to zero, it outputs the nodes after the release node:\
	\
		
\f2\fs18 \cf2 //release node is node 2; releases after 5 sec
\f1\fs24 \cf0 \
		
\f2\fs18 \cf3 Env\cf0 .new([0.001,1,0.3,0.8,0.001],[2,3,1,4] * 0.2, 2, 2).test(5).plot;\
		\cf3 Env\cf0 .new([0.001,1,0.3,0.8,0.5,0.8,0],[2,3,1,2,2,1] * 0.2, 2, 2).test(5).plot;\
		\cf2 //instant release\cf0  \
		\cf3 Env\cf0 .new([0.001,1,0.3,0.8,0.5,0.8,0],[2,3,1,2,2,1] * 0.2, 2, 2).test(0.1).plot; 
\f1\fs24 \
		\
If a loop node is given, the EnvGen outputs the nodes between the release node and the loop node until it is released:\
		\
		
\f2\fs18 \cf2 //release node is node 3, loop node is node 1
\f1\fs24 \cf0 \
		
\f2\fs18 \cf3 Env\cf0 .new([0.001,1,0.3,0.8,0.5,0.8,0],[2,1,1,2,3,1] * 0.1, 'lin', 3, 1).test(3).plot; 
\f1\fs24 \
\

\f0\b Note:
\f1\b0 \
	\
The starting level for an envelope segment is always the level you are at right now. For example when the gate is released and you jump to the release  segment, the level does not jump to the level at the beginning of the release segment, it changes from the whatever the current level is to the goal level of the release segment over the specified duration of the release segment.\
\
There is an extra level at the beginning of the envelope to set the initial level. After that each node is a goal level and a duration, so node zero has duration equal to times[0] and goal level equal to levels[1].\
	\
The loop jumps back to the loop node. The endpoint of that segment is the goal level for that segment and the duration of  that segment will be the time over which the level changed from the current level to the goal level.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 *
\f0\b newClear(numSegments)\

\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li560\fi-560\ql\qnatural
\cf0 	Creates a new envelope specification with 
\f0\b numSegments
\f1\b0  for filling in later. This can be useful when passing Env parameters as args to a 
\f0\b [\ul Synth\ulnone ]
\f1\b0 . Note that the maximum number of segments is fixed and cannot be changed once embedded in a 
\f0\b [\ul SynthDef\ulnone ]
\f1\b0 . Trying to set an Env with more segments than then this may result in other args being unexpectedly set.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\
		
\f2\fs18 (\
		\cf3 SynthDef\cf0 (\cf5 "Help-Env-newClear"\cf0 , \{ \cf3 arg\cf0  i_outbus=0, t_gate ;\
			\cf3 var\cf0  env, envctl;\
			\cf2 // make an empty 4 segment envelope\cf0 \
			env = \cf3 Env\cf0 .newClear(4);\
			\cf2 // create a control argument array\cf0 \
			envctl = \cf3 Control\cf0 .names([\cf4 \\env\cf0 ]).kr( env.asArray );\
			\cf3 Out\cf0 .ar(i_outbus, \cf3 SinOsc\cf0 .ar(\cf3 EnvGen\cf0 .kr(envctl, t_gate), 0, 0.3));\
		\}).send(s);\
		)\
		(\
		s.makeBundle(\cf3 nil\cf0 , \{\
			\cf2 // must not have more segments than the env above\cf0 \
			e = \cf3 Env\cf0 ([700,900,900,800], [1,1,1], \cf4 \\exp\cf0 ); \cf2 // 3 segments\cf0 \
			x = \cf3 Synth\cf0 (\cf5 "Help-Env-newClear"\cf0 , [\cf4 \\t_gate\cf0 , 1]);\
			x.setn(\cf4 \\env\cf0 , e.asArray);\
		\});\
		)\
		(\
		\cf2 // reset then play again\cf0 \
		e = \cf3 Env\cf0 ([800,300,400,500,200], [1,1,1,1], \cf4 \\exp\cf0 ); \cf2 // 4 segments\cf0 \
		x.setn(\cf4 \\env\cf0 , e.asArray);\
		x.set(\cf4 \\t_gate\cf0 , 1);\
		)\
		x.free;\cf5 \
		
\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Standard Shape Envelope Creation Methods
\f2\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
The following class methods create some frequently used envelope shapes based on supplied durations.\
	\
*
\f0\b linen(attackTime, sustainTime, releaseTime, level, curve)\

\f1\b0  \
	 Creates a new envelope specification which has a trapezoidal shape.\
	 
\f0\b attackTime
\f1\b0  - the duration of the attack portion.\
	 
\f0\b sustainTime
\f1\b0  - the duration of the sustain portion.\
	 
\f0\b releaseTime
\f1\b0  - the duration of the release portion.\
	 
\f0\b level
\f1\b0  - the level of the sustain portion.\
	 
\f0\b curve
\f1\b0  - the curvature of the envelope.\
\
		
\f2\fs18 s.boot;\
		\cf3 Env\cf0 .linen(1, 2, 3, 0.6).test.plot;\
		\cf3 Env\cf0 .linen(0.1, 0.2, 0.1, 0.6).test.plot;\
		\cf3 Env\cf0 .linen(1, 2, 3, 0.6, \cf4 'sine'\cf0 ).test.plot;\
		\cf3 Env\cf0 .linen(1, 2, 3, 0.6, \cf4 'welch'\cf0 ).test.plot;\
		\cf3 Env\cf0 .linen(1, 2, 3, 0.6, -3).test.plot;\
		\cf3 Env\cf0 .linen(1, 2, 3, 0.6, -3).test.plot;
\fs24 \
	
\f1 \
\
*
\f0\b triangle(duration, level)\

\f1\b0  \
	 Creates a new envelope specification which has a triangle shape.\
	 
\f0\b duration
\f1\b0  - the duration of the envelope.\
	 
\f0\b level
\f1\b0  - the peak level of the envelope.\
	 \
	 
\f2\fs18 	\cf3 Env\cf0 .triangle(1, 1).test.plot;
\fs24 \

\f1 \
\
*
\f0\b sine(duration, level)\

\f1\b0  \
	 Creates a new envelope specification which has a hanning window shape.\
	 
\f0\b duration
\f1\b0  - the duration of the envelope.\
	 
\f0\b level
\f1\b0  - the peak level of the envelope.\
	 \
	 	
\f2\fs18 \cf3 Env\cf0 .sine(1,1).test.plot;\

\f1\fs24 	\cf2 \
	\cf0 	\
*
\f0\b perc(attackTime, releaseTime, peakLevel, curve)\

\f1\b0  \
	Creates a new envelope specification which (usually) has a percussive shape.\
	
\f0\b attackTime
\f1\b0  - the duration of the attack portion.\
	
\f0\b releaseTime
\f1\b0  - the duration of the release portion.\
	
\f0\b peakLevel
\f1\b0  - the peak level of the envelope.\
	
\f0\b curve
\f1\b0  - the curvature of the envelope.\
	 
\f2 \
		
\fs18 \cf3 Env\cf0 .perc(0.05, 1, 1, -4).test.plot;\
		\cf3 Env\cf0 .perc(0.001, 1, 1, -4).test.plot;	\cf2 // sharper attack\cf0 \
		\cf3 Env\cf0 .perc(0.001, 1, 1, -8).test.plot;	\cf2 // change curvature\cf0 \
		\cf3 Env\cf0 .perc(1, 0.01, 1, 4).test.plot;	\cf2 // reverse envelope
\fs24 \cf0 \
		
\f1 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Sustained Envelope Creation Methods
\f2\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 \
The following methods create some frequently used envelope shapes which have a sustain segment.\
\
*
\f0\b adsr(attackTime, decayTime, sustainLevel,  releaseTime, peakLevel, curve)\
	
\f1\b0  \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li560\fi-560\ql\qnatural
\cf0 	Creates a new envelope specification which is shaped like traditional analog attack-decay-sustain-release (adsr) envelopes.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	
\f0\b attackTime
\f1\b0  - the duration of the attack portion.\
	
\f0\b decayTime
\f1\b0  - the duration of the decay portion.\
	
\f0\b sustainLevel
\f1\b0  - the level of the sustain portion as a ratio of the peak level.\
	
\f0\b releaseTime
\f1\b0  - the duration of the release portion.\
	
\f0\b peakLevel
\f1\b0  - the peak level of the envelope.\
	
\f0\b curve
\f1\b0  - the curvature of the envelope.\
	 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\fs18 \cf0 		\cf3 Env\cf0 .adsr(0.02, 0.2, 0.25, 1, 1, -4).test(2).plot;\
		\cf3 Env\cf0 .adsr(0.001, 0.2, 0.25, 1, 1, -4).test(2).plot;		\
		\cf2 //release after 0.45 sec\cf0 \
		\cf3 Env\cf0 .adsr(0.001, 0.2, 0.25, 1, 1, -4).test(0.45).plot;
\fs24 \cf2 	
\f1 \cf0 \
*
\f0\b dadsr(delayTime, attackTime, decayTime, sustainLevel,  releaseTime, peakLevel, curve)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f1\b0 \cf0 	As 
\f0\b *adsr
\f1\b0  above, but with it's onset delayed by 
\f0\b delayTime
\f1\b0  in seconds. The default delay is 0.1.\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 *
\f0\b asr(attackTime, sustainLevel,  releaseTime, peakLevel, curve)\

\f1\b0  \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li560\fi-560\ql\qnatural
\cf0 	Creates a new envelope specification which is shaped like traditional analog attack-sustain-release (asr) envelopes.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	
\f0\b attackTime
\f1\b0  - the duration of the attack portion.\
	
\f0\b sustainLevel
\f1\b0  - the level of the sustain portion as a ratio of the peak level.\
	
\f0\b releaseTime
\f1\b0  - the duration of the release portion.\
	
\f0\b peakLevel
\f1\b0  - the peak level of the envelope.\
	
\f0\b curve
\f1\b0  - the curvature of the envelope.\
	 \
	
\f2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 		\cf3 Env\cf0 .asr(0.02, 0.5, 1, 1, -4).test(2).plot;\
		\cf3 Env\cf0 .asr(0.001, 0.5, 1, 1, -4).test(2).plot; \cf2 // sharper attack\cf0 \
		\cf3 Env\cf0 .asr(0.02, 0.5, 1, 1, \cf4 'linear'\cf0 ).test(2).plot; \cf2 // linear segments
\f1\fs24 \cf0 \
	
\f2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 *
\f0\b cutoff(releaseTime, level, curve)\

\f1\b0  \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	Creates a new envelope specification which has no attack segment. It simply sustains at the peak level until released. Useful if you only need a fadeout, and more versatile than 
\f0\b [\ul Line\ulnone ]
\f1\b0 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	
\f0\b releaseTime
\f1\b0  - the duration of the release portion.\
	
\f0\b level
\f1\b0  - the peak level of the envelope.\
	
\f0\b curve
\f1\b0  - the curvature of the envelope.\
	
\f2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs18 \cf0 		\cf3 Env\cf0 .cutoff(1, 1).test(2).plot;\
		\cf3 Env\cf0 .cutoff(1, 1, 4).test(2).plot;\
		\cf3 Env\cf0 .cutoff(1, 1, \cf4 'sine'\cf0 ).test(2).plot;
\f1\fs24 \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Instance Methods
\f1\b0\fs24 \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 blend(anotherEnv, blendFraction)\

\f1\b0 \
	Blend two envelopes. Returns a new Env.\
	
\f0\b anotherEnv
\f1\b0  - an Env.\
	
\f0\b blendFraction
\f1\b0  - a number from zero to one.\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 		
\fs18 a = \cf3 Env\cf0 ([0, 0.2, 1, 0.2, 0.2, 0], [0.5, 0.01, 0.01, 0.3, 0.2]).test.plot;\
		b = \cf3 Env\cf0 ([0, 0.4, 1, 0.2, 0.5, 0], [0.05, 0.4, 0.01, 0.1, 0.4]).test.plot;\
			\
		(\
		\cf3 Task\cf0 (\{\
			f = (0, 0.2 .. 1);\
			f.do \{ \cf3 |u|\cf0 \
				blend(a, b, u).test.plot;\
				2.wait;\
				\cf3 SCWindow\cf0 .allWindows.pop.close; \cf2 // close last opened window\cf0 \
			\}\
		\}).play(\cf3 AppClock\cf0 );\
		)\
\
		\cf2 // in a SynthDef\cf0 \
		(\
		\cf3 SynthDef\cf0 (\cf5 "Help-EnvBlend"\cf0 , \{ \cf3 arg\cf0  fact = 0;\'ca
\f1\fs24 \
			
\f2\fs18 \cf3 Out\cf0 .ar(0, \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .perc.blend(\cf3 Env\cf0 .sine, fact), 1.0, doneAction: 2)\'ca
\f1\fs24 \
				
\f2\fs18 * \cf3 SinOsc\cf0 .ar(440,0,0.1)
\f1\fs24 \
			
\f2\fs18 )\'ca
\f1\fs24 \
		
\f2\fs18 \}).send(s));
\f1\fs24 \
		
\f2\fs18 \
		(\
		\{
\f1\fs24 \
		
\f2\fs18 f = (0, 0.1..1);
\f1\fs24 \
		
\f2\fs18 f.do(\{\cf3 |fact|\cf0  \cf3 Synth\cf0 (\cf5 "Help-EnvBlend"\cf0 , [\cf4 \\fact\cf0 , fact.postln]); 1.wait;\});
\f1\fs24 \
		
\f2\fs18 \
		\}.fork;)\
		
\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 delay(delay)\

\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li560\fi-560\ql\qnatural
\cf0 	Returns a new Env based on the receiver in which the start time has been offset by adding a silent segment at the beginning.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	
\f0\b delay
\f1\b0  - The amount of time to delay the start of the envelope.\
	\
		
\f2\fs18 a = \cf3 Env\cf0 .perc(0.05, 1, 1, -4);\
		b = a.delay(2);\
		a.test.plot;\
		b.test.plot;
\f1\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li560\fi-560\ql\qnatural

\f0\b \cf0 \
circle(timeFromLastToFirst, curve)\
\
	
\f1\b0 circle from end to beginning over the time specified, with the curve specified. \
	\

\f2\fs18 \cf3 	\cf6 (\
	\{ \cf7 SinOsc\cf6 .ar(\
		\cf7 EnvGen\cf6 .kr(\
			\cf7 Env\cf6 ([6000, 700, 100], [1, 1], [\cf8 'exp'\cf6 , \cf8 'lin'\cf6 ]).circle.postcs)\
		) * 0.1 \
		+ \cf7 Impulse\cf6 .ar(1) \
	\}.play;\
	)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 \
	(\
	\{ \cf3 SinOsc\cf0 .ar(\
		\cf3 EnvGen\cf0 .kr(\
			\cf3 Env\cf0 ([6000, 700, 100], [1, 1], [\cf4 'exp'\cf0 , \cf4 'lin'\cf0 ]).circle(1).postcs, \
			\cf3 MouseX\cf0 .kr > 0.5)\
		) * 0.1 \
		+ \cf3 Impulse\cf0 .ar(1) \}.play;\
	)
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural

\f2 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 test(releaseTime)\

\f1\b0 \
	Test the envelope on the default 
\f0\b [\ul Server\ulnone ]
\f1\b0  with a 
\f0\b [\ul SinOsc\ulnone ]
\f1\b0 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	
\f0\b releaseTime
\f1\b0  - If this is a sustaining envelope, it will be released after this much time in seconds. The default is 3 seconds.
\f2 \
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 plot(size, bounds, minval, maxval, parent)\

\f1\b0 \
	Plot this envelope's shape in a window.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1140\fi-1140\ql\qnatural
\cf0 	
\f0\b size
\f1\b0  - The size of the plot. The default is 400.\
	
\f0\b bounds 
\f1\b0 - the size of the plot window.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf0 	
\f0\b minval
\f1\b0  - the minimum value in the plot. Defaults to the lowest value in the data.\
	
\f0\b maxval
\f1\b0  - the maximum value in the plot. Defaults to the highest value in the data.\
	
\f0\b parent
\f1\b0  - a window to place the plot in. If nil, one will be created for you
\f2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 asSignal(length)\

\f1\b0 \
	Returns a Signal of size 
\f0\b length
\f1\b0  created by sampling this Env at 
\f0\b length
\f1\b0  number of intervals.\
	\

\f0\b asArray\

\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li560\fi-560\ql\qnatural
\cf0 	Converts the Env to an Array in a specially ordered format. This allows for Env parameters to be settable arguments in a 
\f0\b [\ul SynthDef\ulnone ]
\f1\b0 . See example above under *
\f0\b newClear
\f1\b0 .\
	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 isSustained\

\f1\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li560\fi-560\ql\qnatural
\cf0 	Returns true if this is a sustaining envelope, false otherwise.\
	\

\f0\b \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 	
\f2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs28 \cf0 Client-side Access and Stream Support
\f2\b0\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1 \cf0 Sustain and loop settings have no effect in the methods below.\
 
\f2 \

\f0\b at(time)\

\f1\b0 \
	Returns the value of the Env at 
\f0\b time
\f1\b0 .\
	\
		
\f2\fs18 \cf3 Env\cf0 .triangle(1, 1).at(0.5);
\f1\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 				\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 embedInStream\

\f1\b0 \
	Embeds this Env within an enclosing 
\f0\b [\ul Stream\ulnone ]
\f1\b0 . Timing is derived from 
\f2\fs18 \cf3 thisThread\cf0 .beats
\f1\fs24 .
\f2 \
\

\f0\b asStream\

\f1\b0 \
	Creates a Routine and embeds the Env in it. This allows the Env to function as a 
\f0\b [\ul Stream\ulnone ]
\f1\b0 .\
	\
		
\f2\fs18 (\
		\{\
		e = \cf3 Env\cf0 .sine.asStream;\
		5.do(\{\
			e.next.postln;\
			0.25.wait;\
		\})\}.fork\
		)}