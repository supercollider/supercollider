title:: 03
summary:: Mark Polishook tutorial (JP)
categories:: Tutorials>Mark_Polishook_tutorial>Japanese_version
related:: Tutorials/Mark_Polishook_tutorial/00_Introductory_tutorial

section::SynthDefsには2つの重要な部分がある

SynthDefsは、SuperColliderでシンセサイザーのエンジンを作るのに使うクラスです。

SynthDefsには2つの重要な部分があります。それは、名前と関数です。SuperColliderの用語では、関数はしばしばugenGraphFuncと呼ばれます。

////////////////////////////////////////////////////////////////////////////////////////////////////

ugenGraphFuncという言葉は、ユニット・ジェネレータを、一種のデータ構造であるグラフの形式で記述する関数、という考え方から来ています。SuperColliderは、関数の中に見つけたコードに基づいてグラフを生成します。これは、実際には、グラフという考え方がどのように機能するのかということに関しては、それを使う場合には知らなくてもいいということを意味します。

しかし、グラフに関するさらなる背景を説明するために、http://www.nist.gov/dads/HTML/graph.htmlでのグラフに関する議論を引用します。

「グラフはロードマップの様なものです。都市は頂点です。都市から都市への道路はエッジです。（道路のジャンクションや分岐はどうでしょう？ジャンクションもまた頂点と見なすことができます。もしそれらを頂点としてカウントしたくないのであれば、道路は２つ以上の都市を結ぶでしょう。つまり、厳密にいえば、ハイパーグループにはハイパーエッジがあるのです。もしそれぞれの１組の都市の間に１本以上の道路を許可したいのであれば、代わりにマルチグラフがあります。これはあなたがどのように定義したいのか次第です）。

グラフに関する他の考え方とは、線によって接続された点の集まりというものです。かなり昔に数学者は普通の人々に話しかけるのを辞めてしまったため、グラフの中の点は頂点と呼ばれ、点に接続された線はエッジと呼ばれます。重要なのはエッジと頂点、つまり、点とそれらの間の接続です。与えられた点の位置や与えられた線の真直度は問題ではありません。かくして、点はどこにもなることができ、それらをつなぐ線は無限に伸縮性があります。さらに、数学的なグラフは、比較表や、xとy軸のある図や、株価のレポートのくねった線ではありません。グラフとは単純に点とそれらの間の線なのです。すみません、頂点とエッジです。」

////////////////////////////////////////////////////////////////////////////////////////////////////

code::
// synthdefのテンプレート ... 疑似コードを含む
SynthDef(
	"i am a synthdef",			// 第１アーギュメントは名前
	{ .... i am a ugenGraphFunc ... }	// 第２アーギュメントはUGen
)
::

次の数行のコードは実際のSuperColliderのコードのテンプレートを示します。synthdefの第１アーギュメントは名前で、第２アーギュメントが関数です。

code::
(
SynthDef(
	"aSynthDef", 				// SynthDefの名前
	{ 					// ugenGraphFunc
		arg freq;
		Out.ar(
			0,
			SinOsc.ar(freq, 0, 0.1)
		)
	}
).load(s);
)
::

////////////////////////////////////////////////////////////////////////////////////////////////////

section::SynthDefブラウザー

典型的には、ugenGraphFuncは2、3の重要なコンポーネントを含みます。これらにはugen（ユニット・ジェネレータ）、control（コントロール）、input（入力）そしてoutput（出力）が含まれます。

ブラウザー・ウィンドウでそのようなことを見るためには、次のコードを実行してみて下さい。

code::
(
SynthDescLib.global.read;
SynthDescLib.global.browse;
)
::

このコードによって作られるブラウザー・ウィンドウは６つのボックスを含み、全ての以前に定義されたSynthDefの名前を示します。それぞれの名前を選択して、それに関連づけられたugenGraphFunc ugen、control、inputとoutputを表示することができます。

あらかじめ定義されたSynthDefとは、以前に.loadメッセージが送られたものということです。この結果、SuperColliderはあらかじめロードされたSynthDefを起動時に読み込むます。

.loadメッセージによってSynthDefはディスクに書き込まれ、アクティブなサーバーに送られます。これに対して、.sendメッセージは、最初に定義をディスクに書き込むことなしに、ネットワークを通じてサーバーにSynthDefを送ります。

ニュース速報！：つい最近、新しいメッセージー.storeが定義されました。.storeメッセージは.loadまたは.sendよりも望ましい場合があります。SynthDefをディスクに書き込むことに加えて、SynthDefブラウザー・ウィンドウとかつ／またはパターン・クラスからアクセスできるライブラリに配置します。

////////////////////////////////////////////////////////////////////////////////////////////////////

section::ugenGraphFuncのコンポーネント

SynthDefブラウザーは定義されたSynthDefを表示します。先ほどの「aSynthDef」は4つのugenから構成されています。それには1つのcontrolがあります。それにはinputがありません。そしてそれには1つのoutputがあります。

ブラウザーで表示される様に、4つのugenはControl、SinOsc、BinaryOpUGenそしてOutそれぞれのインスタンスを含みます。この例では、このSynthDefを完全に機能する様にするために、SuperColliderはControlとBinaryOpUGenのインスタンスをインストールしています。他の全てのugenは指定したときだけ存在します。

このSynthDefの1つのコントロールは「freq」で、これはシンセが生成される時、あるいはサーバー上にある時であればいつでも使うことのできるアーギュメントです。ブラウザーは「aSynth」には入力が無いことを示しています。これが意味するのは、このSynthDefがInクラスのインスタンスを使っていないということです。

ブラウザーは、このSynthDefがチャンネル0に1チャンネル分の出力を指定しているということをも示します。

ブラウザーで表示されている他のSynthDefに関して、どのように構築されているのか調べてみて下さい。

////////////////////////////////////////////////////////////////////////////////////////////////////

go to link::Tutorials/Mark_Polishook_tutorial/Japanese_version/04::
