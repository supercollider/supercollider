class::Process
categories::Core>Kernel
summary:: Runtime environment for the virtual machine and interpreter.

description::
A Process is the runtime environment for the virtual machine and interpreter.
It has a subclass named link::Classes/Main:: which is where you should override the methods
of Process. There are two methods of interest. One is named code::startup:: and is
called after the class library has been compiled. The other is named code::run:: and
is called when the user chooses the Run menu command.

classMethods::

method::tailCallOptimize
Get or set tail call optimization. The default is on. Setting this to code::false:: can help with debugging by including intermediate levels in an error backtrace.

instanceMethods::

method::nowExecutingPath

Usage: code::thisProcess.nowExecutingPath::


teletype::nowExecutingPath:: is valid only for interactive code, i.e., code files with a teletype::.scd:: extension. It does not apply to class definitions (teletype::.sc::). For that, use code::thisMethod.filenameSymbol:: or code::this.class.filenameSymbol::.

WARNING:: teletype::nowExecutingPath:: has a corresponding setter method, teletype::nowExecutingPath_::, for internal use only by the interpreter. Do not call the setter method!::

Returns:: The full path to the file containing the code that is currently executing emphasis::interactively:: in the interpreter when used in the command-line interface (CLI), and IDE such as SuperCollider IDE and the scel (SuperCollider-Emacs-Lisp) environment. In some environments, it can return code::nil::
Usually this is the current document. If a code block ("fileMain.scd" in the example code below) executes another file on disk ("fileForLoad.scd" in the example code below), using link::Classes/String#-load:: or link::Classes/String#-loadPaths::, teletype::nowExecutingPath:: will be the location of the executed file ("fileForLoad.scd" in the example code below). However, if the function is called in the executed file ("fileForLoad.scd" in the example code below), teletype::nowExecutingPath:: will be the code block ("fileMain.scd" in the example code below).

code::
(
var fileMainPath, fileMain, fileForLoad;

fileMainPath = "~/Downloads/fileMain.scd".standardizePath;
fileMain = File(fileMainPath, "w");
fileMain.write("(
(" ++ "thisProcess.nowExecutingPath in fileMain.scd:".quote + "+ thisProcess.nowExecutingPath).postln;\n
~test = (thisProcess.nowExecutingPath.dirname +/+" + "fileForLoad.scd".quote ++");\n
~test.load.function1;\n
~test.openOS; // because .openDocument only works in SC-IDE\n
'fileMain.scd tasks finished'.postln;
)");
fileMain.close;

fileForLoad = File(fileMainPath.dirname +/+ "fileForLoad.scd", "w");
fileForLoad << ("(
" ++ "thisProcess.nowExecutingPath in fileForLoad.scd:".quote + "+ thisProcess.nowExecutingPath).postln;\n(
function1: {
(" ++ "thisProcess.nowExecutingPath in the function in fileForFunctions.scd:".quote + "+ thisProcess.nowExecutingPath).postln
}\n)");
fileForLoad.close;

fileMainPath.openOS; // because .openDocument only works in SC-IDE\n
)

/* Usage in command line interfece */
// Linux:
sclang '/home/parallels/Downloads/fileMain.scd'

// macOS (/Applications/SuperCollider.app might be changed to properly):
/Applications/SuperCollider.app/Contents/MacOS/sclang ~/Downloads/fileMain.scd

// Windows (C:\Program Files\SuperCollider_dev\ should be changed to properly):
"C:\Program Files\SuperCollider_dev\sclang.exe" %userprofile%\Downloads\fileMain.scd
::

teletype::
-> /Users/prko/Downloads/fileMain.scd
thisProcess.nowExecutingPath in fileMain.scd: /Users/prko/Downloads/fileMain.scd
thisProcess.nowExecutingPath in fileForLoad.scd: /Users/prko/Downloads/fileForLoad.scd
thisProcess.nowExecutingPath in the function in fileForFunctions.scd: /Users/prko/Downloads/fileMain.scd
-> thisProcess.nowExecutingPath in the function in fileForFunctions.scd: /Users/prko/Downloads/fileMain.scd
::

When used in link::Classes/CmdPeriod::, link::Classes/ServerBoot:: or link::Classes/ServerTree::, it will return teletype::nil:::

code::
(
// CmdPeriod.add {
// ServerTree.add {
ServerBoot.add {
	var path = thisProcess.nowExecutingPath;
	("\tServerBoot's thisProcess.nowExecutingPath:" + path).postln
};
s.reboot
)

(
// r {
Routine {
	var path = thisProcess.nowExecutingPath;
	("\tthisProcess.nowExecutingPath in path fork:" + path).postln
}.()
)

(
// s.waitForBoot {
// s.doWhenBooted {
fork {
	var path = thisProcess.nowExecutingPath;
	("\ts.waitForBoot's thisProcess.nowExecutingPath:" + path).postln
};
s.reboot;
)

(
Task {
	var path = thisProcess.nowExecutingPath;
	("\tTask's thisProcess.nowExecutingPath:" + path).postln
}.start
// }.play
)
::

method::startup

called after the class library has been compiled. Override this in class link::Classes/Main:: to do whatever you want.

method::run

called when the user chooses the Run menu command. Override this in class link::Classes/Main:: to do whatever you want.

method::mainThread

The top-level link::Classes/Thread::, i.e the link::Classes/Thread#-parent#parent:: of all
other Threads. This instance of Thread always exists and is created with the Process when
SuperCollider starts.

discussion::

All SuperCollider code initially runs in the context of the main Thread:

list::
## Code evaluated in code editor
## Code evaluated on command line
## Tasks scheduled on any link::Classes/Clock::
## Functions evaluated in response to incoming OSC and MIDI messages
::

This means that link::Classes/Thread#.thisThread#thisThread:: will always initially point
to the main Thread. However, when some code starts a link::Classes/Routine::, the Routine
becomes the current Thread, with the main Thread as its parent.
