class:: GrainBuf
summary:: Granular synthesis with sound stored in a buffer
categories:: UGens>Buffer, UGens>Generators>Granular
related:: Classes/GrainIn, Classes/GrainFM, Classes/GrainSin

classmethods::
private:: categories

method:: ar

argument:: numChannels
the number of channels to output. If 1, mono is returned and pan is ignored.

argument:: trigger
a kr or ar trigger to start a new grain. If ar, grains after the start of the synth are sample accurate.

argument:: dur
size of the grain (in seconds).

argument:: sndbuf
the buffer holding a mono audio signal. If using multi-channel files, use Buffer.readChannel.

argument:: rate
the playback rate of the sampled sound

argument:: pos
the playback position for the grain to start with (0 is beginning, 1 is end of file)

argument:: interp
the interpolation method used for pitchshifting grains:
list::
## 1 = no interpolation
## 2 = linear
## 4 = cubic interpolation (more computationally intensive)
::

argument:: pan
determines where to pan the output.
list::
## If numChannels = 1, no panning is done.
## If numChannels = 2, panning is similar to Pan2.
## If numChannels > 2, panning is the same as PanAz.
::

argument:: envbufnum
the buffer number containing a signal to use for the grain envelope. -1 uses a built-in Hann envelope.

argument:: maxGrains
the maximum number of overlapping grains that can be used at a given time. This value is set at the UGens init time and can't be modified. Defaults to 512. This can be set lower for more efficient use of memory.

warning:: The above parameter is new (post SC 3.3.1) and has the potential to break code written <= 3.3.1. This parameter is BEFORE the mul slot, and you may need to update code to account for this difference. ::

argument:: mul

argument:: add

discussion:: All args except numChannels and trigger are polled at grain creation time.
instancemethods::
private:: init, argNamesInputsOffset

examples::

From a link::Classes/Buffer::
code::
s.boot;
(
var winenv;

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff");
// a custom envelope
winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
z = Buffer.sendCollection(s, winenv.discretize, 1);

SynthDef(\buf_grain_test, { |out, gate = 1, amp = 1, sndbuf, envbuf|
	var pan, env, freqdev;
	// use mouse x to control panning
	pan = MouseX.kr(-1, 1);
	env = EnvGen.kr(
		Env([0, 1, 0], [1, 1], \sin, 1),
		gate,
		levelScale: amp,
		doneAction: Done.freeSelf);
	Out.ar(out,
		GrainBuf.ar(2, Impulse.kr(10), 0.1, sndbuf, LFNoise1.kr.range(0.5, 2),
			LFNoise2.kr(0.1).range(0, 1), 2, pan, envbuf) * env)
}).add;
)

// use built-in env
x = Synth(\buf_grain_test, [\sndbuf, b, \envbuf, -1])

// switch to the custom env
x.set(\envbuf, z)
x.set(\envbuf, -1);

x.set(\gate, 0);
::

From a live signal, using link::Classes/Ndef::s.
code::
(
SynthDef(\help_GrainBuf_mono_synth, {|freq=440, amp=0.2, gate=1, out=0|
    var env = EnvGen.kr(Env.adsr(releaseTime: 0.5), gate: gate, doneAction: 2);
    var sig = RLPF.ar(LFSaw.ar(freq, iphase: Rand(0,2)), freq*4, 1.5);
    Out.ar(out, sig*env*amp);
}).add;

Ndef(\grain_fx, {
    var maxDelaySeconds = 2.0;
    
    var dryMonoSig = \in.ar(0);
    var bufFrames = SampleRate.ir * maxDelaySeconds;
    var buf = LocalBuf(bufFrames, 1);
    
    var phasor = Phasor.ar(end: bufFrames);
    var phasorPos = phasor / bufFrames;
    var trig = Dust.ar(SinOsc.kr(0.33).linexp(-1,1,10,40));
    var grainRate = TIRand.ar(4,16,trig);
    var grainPos = phasorPos - TGaussRand.ar(0, grainRate.reciprocal, trig);
    
    var wetStereoSig;
    buf.clear;
    BufWr.ar(dryMonoSig, buf, phasor);
    wetStereoSig = GrainBuf.ar(
        numChannels: 2,
        trigger: trig,
        dur: TGaussRand.ar(0, maxDelaySeconds/grainRate, trig),
        sndbuf: buf,
        rate: grainRate,
        pos: grainPos,
        pan: TGaussRand.ar(-1, 1, trig),
        mul: 0.5
    );
    
    wetStereoSig = FreeVerb2.ar(wetStereoSig[0], wetStereoSig[1]);
    
    dryMonoSig!2 + wetStereoSig
}).play;

Ndef(\mono_chords, Pbind(
    \instrument, \help_GrainBuf_mono_synth,
    \octave, 4,
    \degree, Pseq([
        [0,2,4], // I
        [3,5,7] - [0,0,7], // IV, 1st inversion
        [5,7,9] - [0,7,7], // V, 2nd inversion
    ], inf),
    \dur, Pseq([4,2,2], 8),
    \legato, 0.95
)) <>> Ndef(\grain_fx);
)
::
