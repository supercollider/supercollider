TITLE:: LevelComp
summary:: Level compensation logic for Splay and SplayAz
categories:: Panning
related:: Classes/Splay, Classes/SplayAz, Guides/Level_Compensation

DESCRIPTION::
Mixing and Panning multichannel signals often requires link::Guides/Level_Compensation::.
LevelComp provides a logic for this that is used internally in the link::Classes/Splay:: and link::Classes/SplayAz:: UGens.
Using the code::levelComp:: argument of code::Splay/Az::, it calculates a level compensation factor applied to the input signals, depending on the number of output channels.

CLASSMETHODS::

METHOD:: new
Calculate a scaling factor based on the code::levelComp:: argument and the number of channels to be mixed.

ARGUMENT:: levelComp
a flag or numeric value:

list::
##code::true:: : equal power level compensation (default)
##code::false:: : off / no level change,
##float between code::0.0:: and code::1.0:: : smooth tuning of levelComp factor:
list::
##code::0.0:: is none -> factor 1
##code::0.5:: is equal power -> factor (1/n).squared
##code::1.0:: is equal amplitude -> factor (1/n)
::
::

ARGUMENT:: rate
the rate for which to calculate - \audio or \control.

ARGUMENT:: n
the number of channels being mixed and scaled.

returns::
the levelComp factor by which to multiply the output signals.

EXAMPLES::

code::Splay:: and code::SplayAz:: use code::LevelComp:: internally via the code::levelComp:: argument, and obtaining rate and number of channels from code::Splay/Az::.

Here is an Overview of the code::levelComp:: usage variants:
code::
// default is equal power comp: level / (numchans.sqrt)
Splay.ar(ins, spread, level, center); // true is default
// write it explicitly for clarity
Splay.ar(ins, spread, level, center, levelComp: true);
// or do equal power as float levelComp
Splay.ar(ins, spread, level, center, levelComp: 0.5); //

// maximum peak safety by equal amplitude comp: level / numchans
Splay.ar(ins, spread, level, center, levelComp: 1);
// or calculate by hand:
Splay.ar(ins, spread, level / ins.size, center, levelComp: false);

// no compensation, just tune level by hand
Splay.ar(ins, spread, level, center, levelComp: false);
Splay.ar(ins, spread, level, center, levelComp: 0);

// levelComp by float: level / (numchans ** levelComp),
// so 0.0 is no compensation: level / 1;
//    0.5 is equal power : level / (numchans.sqrt)
//    1.0 is equal amplitude : level / (numchans)
// can be used to tune e.g. between equal power and equal amp:
Splay.ar(ins, spread, level, center, levelComp: 0.75);

::

subsection:: Discussion and demonstration of level compensation options:
code::

s.meter;
s.scope;

// synthesize 2 signals at level 0.1 (-20 dB), on separate channels
(
{ var n = 2, level = 0.1, spread = 1, pan = 0;
	LFPulse.ar({ 100.exprand(2000) } ! n).range(-1, 1) * level
}.play;
)

// now using Splay with 2 inputs, level at 0.1 (-20dB)
(
x = { |spread = 1, level = 0.1, center = 0|
    var n = 2;
	var snd = LFPulse.ar({ 100.exprand(2000) } ! n).range(-1, 1);
	var stereo = Splay.ar(snd, spread, level, center);
	Peak.ar(stereo, Impulse.kr(2)).ampdb.poll(2);
    stereo
}.play;
)

// full spread, panned to center:
// the 2 signals are discrete, left and right
// we see the energy-based levelComp applied (1/2.sqrt).ampdb = -3
x.set(\spread, 1, \center, 0); // -20 - 3 = -23dB

// no spread, panned center:
// each signal decreases by 3dB as they move to the center (from the panning function)
// and the two signals mix on each channel, increasing the peak by 6dB
x.set(\spread, 0, \center, 0); // -23 - 3 + 6 = -20dB

// no spread, panned fully right:
// the signals fully mix in the right channel (+6 dB)
x.set(\spread, 0, \center, 1); // -23 + 6 = -17db

//// The same tests with 20 channels, levelComp true as is default:
(
x = { |spread = 1, level = 0.1, center = 0|
	var n = 20;
	var snd = Splay.ar(LFPulse.ar({ 100.exprand(2000) } ! n).range(-1, 1),
		spread, level, center);
	Amplitude.ar(snd, 0.01, 1).ampdb.poll(1);
	snd
}.play;
)

// at full spread, level -20, pan to center:
// amplitude is somewhat higher at -17 db
x.set(\spread, 1, \center, 0);
// with no spread, i.e. all panned center, a bit higher : -16 db
x.set(\spread, 0, \center, 0);
// worst case: no spread, pan full left: -14db
x.set(\spread, 0, \center, -1);


// Finally, here the theoretical worst case for 20 channels: 13 db too loud!
{ Splay.ar(DC.ar(1!20), 0, 1, 0.999).ampdb }.plot;
{ Splay.ar(DC.ar(1!200), 0, 1, 0.999).ampdb }.plot; // 200: 23 db louder
{ Splay.ar(DC.ar(1!2000), 0, 1, 0.999).ampdb }.plot; // 2000: 33 db louder


// So for maximum peak safety, use levelComp 1, or equivalently,
// turn levelComp off / false, and explicitly set level to 1/n.
// and divide by the number of channels - i.e. equal amplitude:
{ n = 2; Splay.ar(DC.ar(1!n), 1, 1, 0, levelComp: 1).ampdb }.plot; // -6 db on both
{ n = 2; Splay.ar(DC.ar(1!n), 1, 1/n, 0, levelComp: false).ampdb }.plot;
{ n = 2; Splay.ar(DC.ar(1!n), 0, 1, 0, levelComp: 1).ampdb }.plot; // -3 db on both
{ n = 2; Splay.ar(DC.ar(1!n), 0, 1, 0.99, levelComp: 1).ampdb }.plot; // 0 db

// these are now the same for all tested values of n:
{ n = 20; Splay.ar(DC.ar(1!n), 1, 1, 0, levelComp: 1).ampdb }.plot; // -4 db
{ n = 20; Splay.ar(DC.ar(1!n), 0, 1, 0, levelComp: 1).ampdb }.plot; // -3 db
{ n = 20; Splay.ar(DC.ar(1!n), 0, 1, 0.99, levelComp: 1).ampdb }.plot; // 0 db on right

{ n = 200; Splay.ar(DC.ar(1!n), 1, 1, 0, levelComp: 1).ampdb }.plot; // -4 db
{ n = 200; Splay.ar(DC.ar(1!n), 0, 1, 0, levelComp: 1).ampdb }.plot; // -3 db
{ n = 200; Splay.ar(DC.ar(1!n), 0, 1, 0.99, levelComp: 1).ampdb }.plot; // 0 db on right

{ n = 2000; Splay.ar(DC.ar(1!n), 1, 1, 0, levelComp: 1).ampdb }.plot; // -4 db
{ n = 2000; Splay.ar(DC.ar(1!n), 0, 1, 0, levelComp: 1).ampdb }.plot; // -3 db
{ n = 2000; Splay.ar(DC.ar(1!n), 0, 1, 0.99, levelComp: 1).ampdb }.plot; // 0 db on right
::
