class:: Pipe
summary:: pipe stdin to, or stdout from, a UNIX shell command
related:: Classes/UnixFILE
categories:: Files

description::
Pipe stdin to, or stdout from, a UNIX shell command. Pipe treats the shell command as if it were a UnixFILE, and returns nil when done. See link::Classes/UnixFILE:: for details of the access methods. Pipe must be explicitly closed. Do not rely on the garbage collector to do this for you!

ClassMethods::

method::new

argument::commandLine
A link::Classes/String:: representing a valid shell command.

argument::mode
A link::Classes/String:: representing the mode. Valid modes are "w" (pipe to stdin) and "r" (pipe from stdout).

method::argv

argument::executableAndArguments
A link::Classes/SequenceableCollection:: containining strings where the first string is the path to the executable to be run and all other strings are passed as arguments to the executable. This method starts the process directly without using a shell.

argument::mode
A link::Classes/String:: representing the mode. Valid modes are "w" (pipe to stdin) and "r" (pipe from stdout).

method::callSync

Opens a pipe for reading, and retrieves either the command's results as a string or the exit code.

list::
## If the command is successful and there is output to report, the code::onSuccess:: function will be called with two arguments: code::contents, exitCode::. code::exitCode:: should be 0, but is passed just in case something goes wrong.
## If the command is successful and the output is empty, the code::onError:: function will be called with a single argument, code::exitCode::. The exit code will be 0 in this case.
## If the command failed, the code::onError:: function will be called with the error code as the single argument.
::

(That is, this method assumes the command will produce output. If it didn't, it calls the error function, where you can use the exitCode argument to distinguish success or failure.)

argument::command
A string containing the commandline to evaluate.

argument::onSuccess
A function with two arguments: code::contents, exitCode::. code::exitCode:: should be 0 and may normally be ignored.

argument::onError
A function with one argument: code::exitCode::. If 0, it means the command did not encounter any errors but that the output was empty.

argument::maxLineLength
An Integer, for the maximum expected line size.

returns:: Normally returns nil. Command results should be handled in code::onSuccess:: and code::onError::. If the method's return is non-nil, then it is a function to close the pipe.

InstanceMethods::

private::prClose, prOpen, prOpenArgv

method::open
Open the file.

argument::commandLine
A command line link::Classes/String:: passed to popen.

argument::mode
A link::Classes/String:: passed to popen, so should be one of: "r","w"

method::openArgv
Open the file.

argument::executableAndArguments
A link::Classes/SequenceableCollection:: containining strings where the first string is the path to the executable to be run and all other strings are passed as arguments to the executable. This method starts the process directly without using a shell.

argument::mode
A link::Classes/String:: passed to popen, so should be one of: "r","w"

method::close
Closes the pipe, waiting for the command to finish. You must do this explicitly before the Pipe object is garbage collected.

returns:: The exit status of the command (an Integer).

Examples::

note::
For anyone still using macOS 10.3, UNIX commands like pipe do not work when the server is booted; quit the server, otherwise SuperCollider crashes. More recent macOS is not affected.

::

code::
// this pipes in stdout from ls
(
var p, l;
p = Pipe.new("ls -l", "r");			// list directory contents in long format
l = p.getLine;					// get the first line
while({l.notNil}, {l.postln; l = p.getLine; });	// post until l = nil
p.close;					// close the pipe to avoid that nasty buildup
)
::

without using a shell:

code::
// this pipes in stdout from ls
(
var p, l;
p = Pipe.argv(["ls","-l"], "r");			// list directory contents in long format
l = p.getLine;					// get the first line
while({l.notNil}, {l.postln; l = p.getLine; });	// post until l = nil
p.close;					// close the pipe to avoid that nasty buildup
)
::

A more time-intensive request:
code::
(
var p, l;
p = Pipe.new("ping -c10 sourceforge.net", "r");	// list directory contents in long format
l = p.getLine;					// get the first line
while({l.notNil}, {l.postln; l = p.getLine; });	// post until l = nil
p.close;					// close the pipe to avoid that nasty buildup
)
::
