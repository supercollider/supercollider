title:: File
summary:: a class for reading and writing files
categories:: Files
related:: Classes/FileReader


description::


A class for reading and writing files. Not sound files.


classmethods::


private:: prGetcwd, prType, openDialog, openDialogs, saveDialog


method::new

creates a File instance and opens the file. If the open fails, link::Classes/UnixFILE#-isOpen#isOpen:: will return code::false::.

argument::pathName
a link::Classes/String:: containing the path name of the file to open.

argument::mode
a link::Classes/String:: indicating one of the following modes:

definitionlist::
## "r" || Opens a file for reading. The file must exist.
## "w" || Creates an empty file for writing. If a file with the same name already exists, its content is erased and the file is treated as a new empty file.
## "a" || Appends to a file. Writing operations appends data at the end of the file. The file is created if it does not exist.
## "rb", "wb", "ab" || same as above, but data is binary
## "r+" || Opens a file for update both reading and writing. The file must exist.
## "w+" || Creates an empty file for both reading and writing. If a file with the same name already exists, its content is erased and the file is treated as a new empty file.
## "a+" || Opens a file for reading and appending. All writing operations are performed at the end of the file, protecting the previous content to be overwritten. You can reposition the internal pointer using the seek method to anywhere in the file for reading, but writing operations will move it back to the end of file. The file is created if it does not exist.
## "rb+", "wb+", "ab+" || same as above, but data is binary
::


method::open

same as link::#*new::, but a more intuitive name.


method::getcwd

POSIX standard 'get current working directory'.

code::
// example;
File.getcwd;
::


method::use

opens the file, evaluates the function with the file as argument, and closes it again. If the process fails, closes the file and throw an error.


method::readAllString

opens the file at the given path, calls link::#-readAllString::, and returns the string. Whether the process succeeds or fails, the file will always be closed.

code::
// write a file
File.use("~/test.txt".standardizePath, "w", { |f| f.write("The green fox fell into the blue lake") });

// read it again
File.readAllString("~/test.txt".standardizePath);
::


method::readAllSignal

opens the file at the given path, calls link::#-readAllSignal::, and returns the signal. Whether the process succeeds or fails, the file will always be closed.


method::readAllStringHTML

opens the file at the given path, calls link::#-readAllStringHTML::, and returns the string. Whether the process succeeds or fails, the file will always be closed.


method::readAllStringRTF

opens the file at the given path, calls link::#-readAllStringRTF::, and returns the string. Whether the process succeeds or fails, the file will always be closed.


subsection:: Filesystem utilities


method::exists

answers if a file exists at that path.

note::
Some filesystems, like the one used by macOS, are case insensitive.
On such systems, this method will return code::true:: for "fOo" even if the file is actually named "Foo".
For a workaround, see link::#*existsCaseSensitive:: below.
::

returns::

a link::Classes/Boolean::


method::existsCaseSensitive

like link::#*exists:: but ensure case sensitivity emphasis:: of the last path component :: on case insensitive filesystems. On case sensitive systems, it falls back to using code::exists::.

note::
This is slower than the normal code::exists:: method, so use it only when really needed.
::


method::systemIsCaseSensitive

answers if the filesystem is case sensitive or not.


method::mkdir

creates directory at path, including any missing parent directories.

returns::

a link::Classes/Boolean::, as follows:

list::
## code::true:: -- A new directory was created at code::path::.
## code::false:: -- A directory already existed at code::path::; a new one was not created.
::


method::delete

deletes the file at that path. Use only for good, never for evil.

returns::

a link::Classes/Boolean::, as follows:

list::
## code::true:: -- You can assume that the path no longer exists. (Either it existed and was deleted, or it didn't exist and it still doesn't exist.)
## code::false:: -- The file could not be deleted (probably a permissions error). Your code should assume that the path still exists.
::


method::deleteAll

deletes the file and all children at that path. Use only for good, never for evil.

returns::

a link::Classes/Boolean::, as follows:

list::
## code::true:: -- At least one file was deleted.
## code::false:: -- No files were deleted.
::

If deletion fails, a PrimitiveFailedError object will be thrown.


method::realpath

follows symbolic links (and aliases on macOS) and any parent directory references (like "..") and returns the code::true:: absolute path.

returns::

a link::Classes/String:: or code::nil:: if path did not exist.


method::copy

copies file, symlink or directory. this method will fail if pathNameTo already exists.

Symlinks are copied as symlinks (re-created).


method::type

gets file type as one of code::\error, \not_found, \regular, \directory, \symlink, \block, \character, \fifo, \socket, \unknown::

returns::

a link::Classes/Symbol::


method::fileSize

gets size of file in bytes.

returns::

an link::Classes/Integer::


method::mtime

gets last modification time in seconds since the Epoch.

returns::

an link::Classes/Integer::


subsection:: Error handling in filesystem utilities


If one of the above filesystem primitives fails, in most cases, a PrimitiveFailedError object will be thrown:

code::
File.mkdir("/usr/oh-no-you-cant");
::

teletype::
ERROR: Primitive '_FileMkDir' failed.
caught exception 'boost::filesystem::create_directory: Permission denied: "/usr/oh-no-you-cant"' in primitive in method Meta_File:mkdir
::

The methods link::Classes/Function#-try:: and link::Classes/Function#-protect:: can detect and handle these errors. See link::Guides/Understanding-Errors:: for details.

Currently, link::Classes/File#*copy::, link::Classes/File#*fileSize::, link::Classes/File#*mkdir::, link::Classes/File#*mtime::, and link::Classes/File#*type:: throw errors upon failure. (link::Classes/File#*delete:: does not throw an error, but instead returns a Boolean.)


instancemethods::


private:: prOpen, prClose


method::open

opens the file. Files are automatically opened upon creation, so this call is only necessary if you are closing and opening the same file object repeatedly.

note::
It is possible when saving files with a standard file dialog to elect to "hide the extension" and save it as RTF. When opening the file you must specify the real filename: "filename.rtf", even though you can't see in file load dialogs or in the Finder.
::


method::close

closes the file.


method::readAllString

reads the entire file as a link::Classes/String::.


method::readAllStringHTML

reads the entire file as a link::Classes/String::, stripping HTML tags.


method::readAllStringRTF

reads the entire file as a link::Classes/String::, stripping RTF formatting.


method::readAllSignal

reads the entire file as a link::Classes/Signal::, where every chunk of four bytes is interpreted as a 32-bit floating point sample.


method::seek

moves the read/write pointer to a given location in the file, where offset is location given in bytes, and origin is the reference of the offset:

definitionlist::
## 0 || offset is from the beginning of the file
## 1 || offset is relative to the current position in the file
## 2 || offset is from the end of the file
::


method::pos

sets/returns the current position in the file (in bytes).
when used as a setter, this method is a shortcut for seek(0, value). so setting the pos moves the current file position to a given location from the beginning of the file. the value is clipped so that it lies between 0 inclusively and the file length exclusively.


method::length

returns the current file size in bytes.


examples::

code::
// write some string to a file:
(
var f, g;
f = File("~/test.txt".standardizePath, "w");
f.write("Does this work?\n is this thing on ?\n");
f.close;
)

// read it again:
(
g = File("~/test.txt".standardizePath, "r");
g.readAllString.postln;
g.close;
)

// try the above with File.use:

File.use("~/test.txt".standardizePath, "w", { |f| f.write("Doesn't this work?\n is this thing really on ?\n") });
File.use("~/test.txt".standardizePath, "r", { |f| f.readAllString.postln });


// more file writing/reading examples:
(
var h, k;
h = File("~/test.dat".standardizePath, "wb");
h.inspect;
h.write(FloatArray[1.1, 2.2, 3.3, pi, 3.sqrt]);
h.close;

k = File("~/test.dat".standardizePath, "rb");
(k.length div: 4).do({ k.getFloat.postln });
k.close;
)


(
var f, g;
f = File("~/test.txt".standardizePath, "w");
100.do({ f.putChar([$a, $b, $c, $d, $e, $\n].choose) });
f.close;

g = File("~/test.txt".standardizePath, "r");
g.readAllString.postln;
g.close;

g = File("~/test.txt".standardizePath, "r");
g.getLine(1024).postln;
"*".postln;
g.getLine(1024).postln;
"**".postln;
g.getLine(1024).postln;
"***".postln;
g.getLine(1024).postln;
"****".postln;
g.close;
)

(
// var f, g;
f = File("~/test.dat".standardizePath, "wb");
f.inspect;
100.do({ f.putFloat(1.0.rand) });

f.inspect;
f.close;

g = File("~/test.dat".standardizePath, "rb");
100.do({
	g.getFloat.postln;
});
g.inspect;
g.close;
)

(
// var f, g;
f = File("~/test.dat".standardizePath, "r");
f.inspect;
f.close;
)
::
