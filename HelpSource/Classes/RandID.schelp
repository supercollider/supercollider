class:: RandID
summary:: Set the synth's random generator ID.
related:: Classes/RandSeed
categories::  UGens>Generators>Stochastic, UGens>Random


Description::

Choose which random number generator to use for this synth.
All synths that use the same generator reproduce the same sequence
of numbers when the same seed is set again.


classmethods::

method::kr, ir

argument::id
The random number generator ID.

argument::force
A Boolean flag. A positive value is 'true', and indicates that RandID should set the synth's random number generator ID on every evaluation, even if the input ID has not changed. Negative or zero is 'false', meaning that RandID should set the synth's random number generator ID only when the input ID changes. Default is 0 (false), for compatibility with versions prior to the addition of this feature.

"Forcing" is useful in the special case where different parts of the same SynthDef graph need to use different random number generators. See examples below.

note:: code::RandID.ir:: will always evaluate only once, at the start of the synth, so the code::force:: argument has no effect in that case. ::


Examples::

code::

//start a noise patch and set the id of the generator
(
SynthDef("help-RandID", { arg out=0, id=1;
	RandID.ir(id);
	Out.ar(out,
		WhiteNoise.ar(0.05) + Dust2.ar(70)
	)
}).add;
)

//reset the seed of my rgen at a variable rate
(
SynthDef("help-RandSeed", { arg seed=1910, id=1;
	RandID.kr(id);
	RandSeed.kr(Impulse.kr(FSinOsc.kr(0.2, 0, 10, 11)), seed);
}).add;

)

//start two noise synths on left and right channel with a different randgen id
a = Synth("help-RandID", [\out, 0, \id, 1]);
b = Synth("help-RandID", [\out, 1, \id, 2]);

//reset the seed of randgen 1
x = Synth("help-RandSeed", [\id, 1]);

//change the target randgen to 2 (affects right channel)
x.set(\id, 2);
::

subsection:: Multiple random number generators and 'force'

In most cases, randomized UGens in a SynthDef may all pull from the same random number generator. In this typical case, it's likely unnecessary to set the ID or re-seed at all.

If, however, one is merging randomized signals from multiple synths into a single synth, and one wants to retain individual control over these separate streams, then the following sequence of evaluation is needed:

numberedlist::
## Set RNG ID (and re-seed).
## Calculate some randomized UGens.
## Set a different RNG ID (and re-seed).
## Calculate some other randomized UGens.
::

This entire sequence needs to be performed, in this order, on every control block.

The original RandID implementation would set the ID only when the input changed. Here, even though the code looks like it should produce two identical pseudo-random sequences, they are different because both LFNoise0 units are using the same RNG (ID = 1).

code::
(
{
	var a, b;
	RandID.kr(0);
	RandSeed.ir(1, 88372);
	a = LFDNoise0.ar(440);
	RandID.kr(1);
	RandSeed.ir(1, 88372);
	b = LFDNoise0.ar(440);
	[a, b, a - b]
}.plot;
)
::

By "forcing" the RNG ID to be updated on every control block, then the random sequences do match.

code::
(
{
	var a, b;
	RandID.kr(0, 1);
	RandSeed.ir(1, 88372);
	a = LFDNoise0.ar(440);
	RandID.kr(1, 1);
	RandSeed.ir(1, 88372);
	b = LFDNoise0.ar(440);
	[a, b, a - b]
}.plot;
)
::

note:: In such cases, use a SynthDef and check the order of UGens carefully.

code::
(
SynthDef(\test, {
	var a, b;
	RandID.kr(0, 1);
	RandSeed.ir(1, 88372);
	a = LFDNoise0.ar(440);
	RandID.kr(1, 1);
	RandSeed.ir(1, 88372);
	b = LFDNoise0.ar(440);
	Out.ar(1000, [a, b, a - b])
}).dumpUGens
)

// correct order! annotated:

// one RNG chain, id = 0
[0_RandID, control, [0, 1]]
[1_RandSeed, scalar, [1, 88372]]
[2_LFDNoise0, audio, [440]]

// another RNG chain, id = 1
[3_RandID, control, [1, 1]]
[4_RandSeed, scalar, [1, 88372]]
[5_LFDNoise0, audio, [440]]

[6_-, audio, [2_LFDNoise0, 5_LFDNoise0]]
[7_Out, audio, [1000, 2_LFDNoise0, 5_LFDNoise0, 6_-]]
::

::
