title:: String
summary:: Array of Chars
categories:: Collections>Ordered
related:: Classes/Char


description::


String represents an array of link::Classes/Char##Chars::.

Strings can be written literally using double quotes:

code::
"my string".class
::

A sequence of string literals will be concatenated together:

code::
x = "hel" "lo";
y = "this is a\n"
    "multiline\n"
    "string";
::

Backslash is the escape character. See link::Reference/Literals#Characters::.


subsection:: Character encodings


Note that, while Char does not support encodings aside from ASCII‚Äîsuch as
multi-byte encodings like UTF-8 and UTF-16, or the full Latin-1 (ISO 8859-1)
character set‚ÄîChars with negative values are perfectly legal, and may be strung
together in strings that use these encodings.

The SuperCollider IDE uses UTF-8 (a superset of ASCII) to decode and display
strings, which means that the string code::"üéπüôÑüéªüòÇüéöÔ∏èüéõÔ∏èüé§üòç":: can be written in
the editor, posted in the post window, and treated for the most part like any
other string.
However, because non-ASCII UTF-8 characters consist of two or more bytes,
and a SuperCollider String's members are one-bit Chars, concepts of size and
indexing may not behave intuitively.
For instance, the "code::size::" of the string above is 38, not 8, and the value
of its first index is code::-16::, which is not a valid ASCII value at all but
rather the signed 8-bit representation of the first byte of the UTF-8 value of
the piano keyboard emoji (üéπ), code::0xF09F8EB9::.


classmethods::


private:: initClass
private:: doUnixCmdAction
private:: unixCmdActions


method::readNew

reads the entire contents of a link::Classes/File:: and returns them as a new String.


method::scDir

deprecated alias for code::Platform.resourceDir::. Please use link::Classes/Platform#*resourceDir:: instead.


instancemethods::


private:: prUnixCmd, prFormat, prCat, prBounds, hash, species, getSCDir, prDrawInRect, prDrawAtPoint, openTextFile


subsection:: Accessing characters


method::@, at

Strings respond to teletype::.at:: in a manner similar to other indexed collections. Each element is a link::Classes/Char::.

code::
"ABCDEFG".at(2)
::


method::ascii

returns an Array of ASCII values of the Strings's characters.

code::
"wertvoll".ascii // [119, 101, 114, 116, 118, 111, 108, 108]
::

Note that if a string contains multi-byte UTF-8 characters, this array will not
be of the same length as the number of visible characters, nor will it
necessarily be an array of valid 7-bit ASCII values.

code::
// "face with tears of joy" is Unicode codepoint U+1F602, which is encoded in UTF-8 as hex value 0xF09F9882
a = "üòÇ";

// although this is one UTF-8 character, it must be stored as 4 Chars because Chars can only hold 1 byte each
a.size // 4 (!)
a.ascii // [-16, -97, -104, -126]

// "wrap(0, 255)" converts these numbers to their unsigned 8-bit values
b = a.ascii.wrap(0, 255) // [240, 159, 152, 130]

// if we represent these values in hexidecmial, it's the same as the UTF-8 above: 0xF09F9882
b.collect(_.asHexString(2)) // [F0, 9F, 98, 82]
::


subsection:: Comparing strings


method::compare

returns an integer less than, equal to or greater than zero, depending on whether the receiver should be sorted before the argument, is equal to the argument or should be sorted after the argument. This is a case sensitive compare.


method::<

returns a link::Classes/Boolean:: whether the receiver should be sorted before the argument.

code::
"same" < "samf"
::


method::>

returns a link::Classes/Boolean:: whether the receiver should be sorted after the argument.

code::
"same" > "samf"
::


method::<=

returns a link::Classes/Boolean:: whether the receiver should be sorted before the argument, including the same string.

code::
"same" <= "same"
"same" <= "samf"
::


method::>=

returns a link::Classes/Boolean:: whether the receiver should be sorted after the argument, including the same string.

code::
"same" >= "same"
"same" >= "samf"
::


method::==

returns a link::Classes/Boolean:: whether the two Strings are equal.

note::
This method is (now) case sensitive!
::

code::
"same" == "same"
"same" == "Same"; // false
::


method::!=

returns a link::Classes/Boolean:: whether the two Strings are not equal.

code::
"same" != "same"; // false
"same" != "Same";
::


subsection:: Fuzzy string comparison


With fuzzy comparison, the strings don't need to match exactly - we can work out how similar they are, and make decisions based on that.
This behaviour is inherited from the link::Classes/SequenceableCollection#-editDistance::, and is documented fully there, but to provide an example:

code::
"hello".editDistance("hallo"); // 1 (substitution)
"hello".editDistance("hell"); // 1 (deletion)
"hello".editDistance("helloo"); // 1 (addition)
"hello".editDistance("hllo"); // 1 (removal)
"hello".editDistance("haldo"); // 2 (substitutions)
::


subsection:: Posting strings


method::post

prints the string to the current post window.

code::
"One".post; "Two".post; "";
::


method::postln

prints the string and a carriage return to the current post window.

code::
"One".postln; "Two".postln; "";
::


method::postc, postcln

as link::#-post:: and link::#-postln::, but formatted as a comment.

code::
"This is a comment.".postcln;
::


method::postf

prints a formatted string with arguments to the current post window. The % character in the format string is replaced by a string representation of an argument. To print a % character use \\% .

code::
postf("this % a %. pi = %, list = %\n", "is", "test", pi.round(1e-4), (1..4))

this is a test. pi = 3.1416, list = [1, 2, 3, 4]
::


method::postcs

as link::#-postln::, but posts the link::#-asCompileString#compileString:: of the receiver.

code::
List[1, 2, ["comment", [3, 2]], { 1.0.rand }].postcs;
::


method::error

prepends an error banner and posts the string.

code::
"Do not press this button again".error;
::


method::warn

prepends a warning banner and posts the string.

code::
"Do not press this button again".warn;
::


method::inform

legacy method (although due to widespread use, it will not be removed). This is identical to code::postln::.


subsection:: Interpreting strings as code


method::compile

compiles a String containing legal SuperCollider code and returns a Function.

code::
(
var f;
f = "2 + 1".compile.postln;
f.value.postln;
)
::


method::interpret

compiles and executes a String containing legal SuperCollider code, returning the result.

code::
"2 + 1".interpret.postln;
::


method::interpretPrint

compiles, executes and prints the result of a String containing legal SuperCollider code.

code::
"2 + 1".interpretPrint;
::


subsection:: Converting strings


method::asCompileString

returns a String formatted for compiling.

code::
(
var f;
f = "myString";
f.postln;
f.asCompileString.postln;
)
::


method::asSymbol

returns a link::Classes/Symbol:: derived from the String.

code::
(
var z;
z = "myString".asSymbol.postln;
z.class.postln;
)
::


method::asInteger

returns an link::Classes/Integer:: derived from the String. Strings beginning with non-numeric characters return 0.

code::
"4".asInteger.postln;
::


method::asFloat

returns a link::Classes/Float:: derived from the String. Strings beginning with non-numeric characters return 0.

code::
"4.3".asFloat.postln;
::


method::asSecs

returns a link::Classes/Float:: based on converting a time string in format code::(ddd:)hh:mm:ss(.z)::, where code::z:: is any sequence of digits. This is the inverse method to link::Classes/SimpleNumber#-asTimeString::.

code::
"00:00:59.900".asSecs; // hh:mm:ss.zzz
"1:1:1.1".asSecs; // h:m:s.z
"001:00:00:00.001".asSecs; // ddd:hh:mm:ss.zzz
"32.1".asSecs;
"32.".asSecs; // trailing period
"32.12345678".asSecs; // any number of decimal places
"62.1".asSecs; // warns
"-1".asSecs; // neg sign supported
"-12:34:56".asSecs; // neg sign always at the beginning
"-23:12.346".asSecs;
"-1:00:00:00".asSecs; // neg with days
"12:-34:56".asSecs; // warns
(45296.789.asTimeString).asSecs; // inverse of aNumber.asTimeString
::


subsection:: Concatenate strings


method::++

returns a concatenation of the two strings.

code::
"hello" ++ "word"
::


method::+

returns a concatenation of the two strings with a space between them.

code::
"hello" + "word"
::


method::+/+

concatenates code::this:: and code::path::, as components of a filesystem path on the host operating
system. The strings are joined to avoid duplicate path separators.

If code::this:: ends with a path separator and code::path:: begins with one, then the separator
in code::path:: is dropped. If there is a path separator on either side, this has the same effect as
using code::++::. If neither side has a path separator, the platform's preferred separator
('\' on Windows, '/' otherwise) is added.

Returns code::this:: and code::path:: concatenated. If code::path:: was a PathName, the result is a
PathName; otherwise, it is a String.

argument::path
any object that can be converted to a string. Typically, either a String, link::Classes/Symbol::, or
link::Classes/PathName::.

code::
// On Windows, this produces "foo\\bar"; on other platforms, "foo/bar"
"foo" +/+ "bar"

// On all platforms, this produces "foo/bar": +/+ prefers using an existing separator
"foo/" +/+ "bar"
"foo" +/+ "/bar"
"foo/" +/+ "/bar"

// On Windows, this produces "foo\\bar"; on other platforms, "foo/\\bar"
"foo" +/+ "\\bar"

// Concatenating a symbol is also OK
"foo" +/+ 'bar'
::


method::catArgs

concatenates this string with the following args.

code::
"These are some args: ".catArgs(\fish, SinOsc.ar, { 4 + 3 }).postln;
::


method::scatArgs

same as link::#-catArgs::, but with spaces in between.

code::
"These are some args: ".scatArgs(\fish, SinOsc.ar, { 4 + 3 }).postln;
::


method::ccatArgs

same as link::#-catArgs::, but with commas in between.

code::
"a String".ccatArgs(\fish, SinOsc.ar, { 4 + 3 }).postln;
::


method::catList, scatList, ccatList

as link::#-catArgs::, link::#-scatArgs:: and link::#-ccatArgs:: above, but takes a Collection (usually a link::Classes/List:: or an link::Classes/Array::) as an argument.

code::
"a String".ccatList([\fish, SinOsc.ar, { 4 + 3 }]).postln;
::


subsection:: Regular expressions


The String class provides access to the boost library's regular expression functions. Boost's default uses Perl settings. (Currently, there is no hook to override the regex style.) Syntax details may be found at link::https://www.boost.org/doc/libs/1_69_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html::.

Note carefully the argument order:

list::
## code::regexp.matchRegexp(stringToSearch)::
## code::stringToSearch.findRegexp(regexp):: (and similar for code::findAllRegexp:: and code::findRegexpAt::).
::

code::findRegexp:: follows the pattern established by link::Classes/String#-find::, where the receiver is the string to be searched. code::matchRegexp:: follows the pattern of link::Reference/matchItem::, where the receiver is the pattern to match and the first argument is the object to be tested. This is a common source of confusion, but it is based on this precedent.


method::matchRegexp

Perl regular expression matching (see link::Classes/String#Regular expressions::). Returns code::true:: if the receiver (a regular expression pattern) matches the string passed to it. The strong::start:: is an offset where to start searching in the string (default: 0), strong::end:: where to stop.

note::
This is code::regexp.matchRegexp(stringToSearch):: and not the other way around! See above: link::Classes/String#Regular expressions::.
::

code::
"c".matchRegexp("abcdefg", 2, 5); // true: substring exists
"c".matchRegexp("abcdefg", 4, 5); // false: substring doesn't exist

"behaviou?r".matchRegexp("behavior"); // true: character may or may not exist
"behaviou?r".matchRegexp("behaviour"); // true: character may or may not exist
"behaviou?r".matchRegexp("behavir"); // false: but the rest does not match
"behavi(ou)?r".matchRegexp("behavir"); // true: the substring in parens may or may not exist
"b.h.v.r".matchRegexp("behavor"); // true
"b.h.v.r".matchRegexp("behaviiiiir"); // false: dot stands for exactly one char
"b.h.vi*r".matchRegexp("behaviiiiir"); // true: (kleene) star stands for any number of chars preceding, or none
"b.h.vi*r".matchRegexp("behavuuuur"); // false
"(a|u)nd".matchRegexp("und"); // true
"(a|u)nd".matchRegexp("and"); // true
"[a-c]nd".matchRegexp("ind"); // false
"[a-c]nd".matchRegexp("bnd"); // true: anything between a and c
"[a-c]*nd".matchRegexp("accacaccacand"); //  true: any combination of a, b, c, or none.
"[xtz]+nd".matchRegexp("xnd"); // true: any combination of x, t, z
::


method::replaceRegexp

this method is used to replace parts of text.

argument::regex
a perl regular expression (see link::Classes/String#Regular expressions::) with which to match the caller.

argument::with
the link::Classes/String:: to replace the found regex with.

returns::

a link::Classes/String::.

code::
// remove numbers
"g8et t8ho9se 3num5b89ers ou06t o8f h12er56e!".replaceRegexp("[0-9]", "")
-> get those numbers out of here!

// remove capital letters
"HelLO WoRlD".replaceRegexp("(\\\w)", "\\\L$1")
-> hello world

// remove all capital letter unless at the start of a word
"HelLO worLD! I weNT tO Paris yeSTErDay.".replaceRegexp("(\\\S)(\\\S*)", "$1\\\L$2")
-> Hello world! I went to Paris yesterday.
::


method::findRegexp

Perl regular expression search (see link::Classes/String#Regular expressions::). This method searches exhaustively for matches and collects them into an array of pairs, in the format code::[character index, matching string]::.

"Leftmost largest match": As in most flavors of regular expressions, code::*:: and code::+:: are greedy; if it is possible to have more than one overlapping match for a part of the regular expression, the match list will include only the leftmost and largest of them. In code::"foobar".findRegexp("o+")::, code::"o+":: may potentially have three matches: code::"o":: at index 1 (second character), code::"o":: at index 2, and code::"oo":: at index 1. code::findRegexp:: will return only the last of these (code::"oo"::), because it begins in the leftmost-possible matching position, and it is the longest possible match at that position.

Note, though, that parentheses for grouping (a "marked sub-expression" or "capturing group") will produce a separate result: code::"aaa".findRegexp("(a+)");:: appears to produce duplicated results code::[[0, aaa], [0, aaa]]::, but this is because the first match is for the parentheses and the second is for code::a+::.

To see the marked sub-expression results more clearly, consider:

code::
"foobar".findRegexp("(o*)(bar)");
-> [[1, oobar], [1, oo], [3, bar]]
::

code::"oobar":: matches the entire regular expression. code::"oo":: and code::"bar":: match the first and second parenthesized sub-expressions, respectively.

code::
"foobar".findRegexp("o*bar");
"32424 334 /**aaaaaa*/".findRegexp("/\\*\\*a*\\*/");
"aaaabaaa".findRegexp("a+");
::

returns::

a nested array, where each sub-array is a pair, code::[character index, matching string]::. If there are no matches, an empty array.


method::findAllRegexp

like link::#-findAll::, but use regular expressions (see link::Classes/String#Regular expressions::). Unlike findRegexp, it returns only the indices of the matches: code::string.findAllRegexp(regexp):: returns the same as code::string.findRegexp(regexp).flop.at(0)::.

code::
"foobar".findAllRegexp("o*bar");
"32424 334 /**aaaaaa*/".findAllRegexp("/\\*\\*a*\\*/");
"foobar".findAllRegexp("(o*)(bar)");
"aaaabaaa".findAllRegexp("a+");
::

returns::

an array of integer character indices pointing to all the possible matches.


method::findRegexpAt

matches a regular expression (see link::Classes/String#Regular expressions::) at the given offset, returning the match and the length of the match in an Array, or code::nil:: if it doesn't match.
The match must begin right at the offset.

code::
"foobaroob".findRegexpAt("o*b+", 0); // nil
"foobaroob".findRegexpAt("o*b+", 1); // [oob, 3]
"foobaroob".findRegexpAt("o*b+", 2); // [ob,  2]
"foobaroob".findRegexpAt("o*b+", 3); // [b,   1]
"foobaroob".findRegexpAt("o*b+", 4); // nil
"foobaroob".findRegexpAt("o*b+", 5); // nil
"foobaroob".findRegexpAt("o*b+", 6); // [oob, 3]
"foobaroob".findRegexpAt("o*b+", 7); // [ob,  2]
::

returns::

an array code::[matching string, length]:: if a match is found at the specified offset; code::nil:: if the offset doesn't match.


subsection:: Searching strings


method::find

returns the index of the string in the receiver, or code::nil:: if not found. If strong::ignoreCase:: is code::true::, code::.find:: makes no difference between uppercase and lowercase letters. The strong::offset:: is the point in the string where the search begins. string may be a String or a link::Classes/Char::.

code::
"These are several words".find("are").postln;
"These are several words".find("fish").postln;
::


method::findBackwards

same like link::#-find::, but starts at the end of the string.

code::
// compare:
"These words are several words".find("words"); // 6
"These words are several words".findBackwards("words"); // 24
::


method::findAll

returns the indices of the string in the receiver, or code::nil:: if not found.

code::
"These are several words which are fish".findAll("are").postln;
"These are several words which are fish".findAll("fish").postln;
::


method::contains

returns a link::Classes/Boolean:: indicating if the String contains string.

code::
"These are several words".contains("are").postln;
"These are several words".contains("fish").postln;
::


method::containsi

same as link::#-contains::, but case insensitive.

code::
"These are several words".containsi("ArE").postln;
::


method::containsStringAt

returns a link::Classes/Boolean:: indicating if the String contains string beginning at the specified index.

code::
"These are several words".containsStringAt(6, "are").postln;
::


method::icontainsStringAt

same as link::#-containsStringAt::, but case insensitive.


method::beginsWith


method::endsWith

returns code::true:: if this string begins/ends with the specified other string.

argument::string
the other string

returns::

a link::Classes/Boolean::


subsection:: Manipulating strings


method::rotate

rotates the string by n steps.

code::
"hello word".rotate(1)
::


method::scramble

randomizes the order of characters in the string.

code::
"hello word".scramble
::


method::replace

like link::#-tr::, but with Strings as well as Chars as arguments.

code::
"Here are several words which are fish".replace("are", "were");
::


method::format

returns a formatted string with arguments. The % character in the format string is replaced by a string representation of an argument. To print a % character use \\% .

code::
format("this % a %. pi = %, list = %\n", "is", "test", pi.round(1e-4), (1..4))

this is a test. pi = 3.1416, list = [1, 2, 3, 4]
::


method::escapeChar

adds the escape character (\) before any character of your choice.

code::
// escape spaces:
"This will become a Unix friendly string".escapeChar($ ).postln;
::


method::quote

returns this string enclosed in double-quote (teletype::"::) characters.

code::
"tell your" + "friends".quote + "not to tread onto the lawn"
::


method::zeroPad

returns this string enclosed in space characters.

code::
"spaces".zeroPad.postcs;
::


method::underlined

returns this string followed by dashes in the next line (teletype::-::).

code::
"underlined".underlined;
"underlined".underlined($~);
::


method::tr

transliteration. Replace all instances of strong::from:: with strong::to::.

code::
":-(:-(:-(".tr($(, $)); // turn the frowns upside down
::


method::padLeft


method::padRight

pads this string with strong::string:: so it fills strong::size:: character.

argument::size
number of characters to fill

argument::string
padding string

code::
"this sentence has thirty-nine letters".padRight(39, "-+");
"this sentence has thirty-nine letters".padLeft(39, "-+");
"this sentence more than thirteen letters".padRight(13, "-+"); // nothing to pad.
::


method::toUpper

returns this string with uppercase letters.

code::
"Please, don't be impolite".toUpper;
::


method::toLower

returns this string with lowercase letters.

code::
"SINOSC".toLower;
::


method::stripRTF

returns a new String with all RTF formatting removed.

code::
(
// same as File-readAllStringRTF
g = File("/code/SuperCollider3/build/Help/UGens/Chaos/HenonC.help.rtf", "r");
g.readAllString.stripRTF.postln;
g.close;
)
::


method::split

returns an Array of Strings split at the separator. The separator is a link::Classes/Char::, and is strong::not:: included in the output array.

code::
"These are several words".split($ );

// The default separator $/ is handy for Unix paths.
"This/could/be/a/Unix/path".split;
::


subsection:: Stream support


method::printOn

prints the String on stream.

code::
"Print this on Post".printOn(Post);

// equivalent to:
Post << "Print this on Post";
::


method::storeOn

same as link::#-printOn::, but formatted link::#-asCompileString::.

code::
"Store this on Post".storeOn(Post);

// equivalent to:
Post <<< "Store this on Post";
::


subsection:: Unix Support


Where relevant, the current working directory is the same as the location of the SuperCollider app and the shell is the Bourne shell (sh). Note that the cwd, and indeed the shell itself, does not persist:

code::
"echo $0".unixCmd; // print the shell (sh)
"pwd".unixCmd;
"cd Help/".unixCmd;
"pwd".unixCmd;

"export FISH=mackerel".unixCmd;
"echo $FISH".unixCmd;
::

It is, however, possible to execute complex commands:

code::
"pwd; cd Help/; pwd".unixCmd;
"export FISH=mackerel; echo $FISH".unixCmd;
::

Also on os x applescript can be called via osascript:

code::
"osascript -e 'tell application \"Safari\" to activate'".unixCmd;
::

Should you need an environment variable to persist you can use link::#-setenv::.

note::
Despite the fact that the method is called 'unixCmd', strong::it does work in Windows::. The string must be a DOS command, however: "dir" rather than "ls" for instance.
::


method::unixCmd

executes a UNIX command strong::asynchronously:: using the standard shell (sh).

argument::action
a link::Classes/Function:: that is called when the process has exited. It is passed two arguments: the exit code and pid of the exited process.

argument::postOutput
a link::Classes/Boolean:: that controls whether or not the output of the process is displayed in the post window.

returns::

an link::Classes/Integer:: - the pid of the newly created process. Use link::Classes/Integer#-pidRunning:: to test if a process is alive.

discussion::
Example:

code::
"ls Help".unixCmd;
"echo one; sleep 1; echo two; sleep 1".unixCmd { |res, pid| [\done, res, pid].postln };
::


method::unixCmdGetStdOut

similar to link::#-unixCmd:: except that the stdout of the process is returned (strong::synchronously::) rather than sent to the post window.

code::
~listing = "ls Help".unixCmdGetStdOut; // Grab
~listing.reverse.as(Array).dupEach.join.postln; // Mangle
::


method::systemCmd

executes a UNIX command strong::synchronously:: using the standard shell (sh).

returns::

error code of the UNIX command


method::runInTerminal

executes the String in a new terminal window (strong::asynchronously::).

argument::shell
the shell used to execute the string.

discussion::

note::
On macOS and Linux, the string is incorporated into a temporary script file and executed using the shell.
::

note::
On Linux, it is possible to choose a specific terminal emulator to be used, otherwise sclang tries to find one by itself. See link::Classes/LinuxPlatform#*runInTerminalCmd::.
::

Example:

code::
"echo ---------Hello delightful SuperCollider user----------".runInTerminal;
::


method::setenv

sets the environment variable indicated in the string to equal the String strong::value::. This value will persist until it is changed or SC is quit. Note that if strong::value:: is a path you may need to call link::#-standardizePath:: on it.

code::
// all defs in this directory will be loaded when a local server boots
"SC_SYNTHDEF_PATH".setenv("~/scwork/".standardizePath);
"echo $SC_SYNTHDEF_PATH".unixCmd;
::


method::getenv

returns the value contained in the environment variable indicated by the String.

code::
"USER".getenv;
::


method::unsetenv

sets the environment variable to code::nil::.


method::mkdir

makes a directory from the given path location.


method::pathMatch

returns an link::Classes/Array:: containing all paths matching this String. Wildcards apply, non-recursive.

code::
Post << "Help/*".pathMatch;
::


method::load

loads and executes the file at the path represented by the receiver.


method::loadPaths

performs link::#-pathMatch:: on this String, then load and execute all paths in the resultant link::Classes/Array::.

code::
// first prepare a file with some code...
(
File.use("/tmp/loadPaths_example.scd", "w", { |file|
	file << "\"This text is the result of a postln command which was loaded and executed by loadPaths\".postln;";
	file <<	"\"I will now throw a dice for you: \".post; 7.rand;"
})
)

// then load the file...
 // ... it posts some text, and the return value pf loadPaths is an array of the return values of each file
"/tmp/loadPaths_example.scd".loadPaths;
::

argument::warn
posts a warning if path doesn't point to any file.

argument::action
if a function is passed, it is called with each path as argument.


method::loadRelative

loads and executes the file at the path represented by the receiver, interpreting the path as relative to the current document or text file. Requires that the file has been saved. This can be used e.g. to load initialization code from files in the same folder.

argument::warn
warns if a file is not found.

argument::action
a function that is called for each file path that is found.


method::resolveRelative

converts the receiver from a relative path to an absolute path, relative to the current document or text file. Requires that the current text file has been saved. Absolute paths are left untransformed.


method::standardizePath

expands teletype::~:: to your home directory, and resolve aliases on macOS. See link::Classes/PathName:: for more complex needs. See link::Classes/File#*realpath:: if you want to resolve symlinks.

code::
"~/".standardizePath; // This will print your home directory
::


method::openOS

opens file, directory or URL via the operating system. On macOS this is implemented via teletype::open::, on Linux via
teletype::xdg-open:: and on Windows via teletype::start::.

code::
Platform.userConfigDir.openOS;
"http://supercollider.sf.net".openOS;
::


subsection:: Pathname Support


Also see link::#-+/+:: for path concatenation.

The term "path separator" is a platform-independent term for the character(s) that can be used to
separate components of a path. On Windows, both forward slash "/" and backward slash "\\" are path
separators. On POSIX-based systems like macOS and Linux, only forward slash is allowed.


method::shellQuote

returns a new string suitable for use as a filename in a shell command, by enclosing it in single quotes (teletype::'::).
If the string contains any single quotes they will be escaped.

discussion::
You should use this method on a path before embedding it in a string executed by link::#-unixCmd:: or link::#-systemCmd::.

code::
unixCmd("ls " + Platform.userExtensionDir.shellQuote)
::

note::
This works well with shells such as strong::bash::, other shells might need different quotation/escaping.
Apart from usage in the construction of shell commands, strong::escaping is not needed:: for paths passed to methods like pathMatch(path) or File.open(path).
::


method::absolutePath


method::asAbsolutePath

returns this path as an absolute path by prefixing it with link::Classes/File#*getcwd:: if necessary.


method::asRelativePath

returns this path as relative to the specified path.

argument::relativeTo
the path to make this path relative to.


method::withTrailingSlash

appends a path separator if one is not already present.


method::withoutTrailingSlash

removes a trailing path separator if one is present.


method::basename

returns the filename from a Unix path.

code::
"Imaginary/Directory/fish.rtf".basename;
::


method::dirname

returns the directory name from a Unix path.

code::
"Imaginary/Directory/fish.rtf".dirname;
::


method::splitext

splits off the extension from a filename or path and returns both in an link::Classes/Array:: as [path or filename, extension].

code::
"fish.rtf".splitext;
"Imaginary/Directory/fish.rtf".splitext;
::


subsection:: YAML and JSON parsing


method::parseYAML

parses this string as YAML/JSON.

returns::

a nested structure of link::Classes/Array::s (for sequences), link::Classes/Dictionary##Dictionaries:: (for maps) and link::Classes/String::s (for scalars).


method::parseYAMLFile

same as code::parseYAML:: but parse a file directly instead of a string. This is faster than reading a file into a string and then parse it.


method::parseJSON

this method is currently just an alias for link::#-parseYAML::, in the future it will only accept valid JSON.

returns::

a nested structure of link::Classes/Array::s (for sequences), link::Classes/Dictionary##Dictionaries:: (for maps) and link::Classes/String::s (for scalars).

code::
"{ \"a\": 1 }".parseYAML;
"{ \"a\": 1 }".parseJSON;
::


method::parseJSONFile

this method is currently just an alias for link::#-parseYAMLFile::, in the future it will only accept valid JSON files.


subsection:: Document Support


method::newTextWindow

creates a new link::Classes/Document:: with this.

code::
"Here is a new Document".newTextWindow;
::


method::openDocument

creates a new link::Classes/Document:: from the path corresponding to this. The selection arguments will preselect the indicated range in the new window. Returns this.

code::
(
String.filenameSymbol.asString.openDocument(10, 20)
)
::


method::findHelpFile

returns the path for the helpfile named this, if it exists, else returns code::nil::.

code::
"Document".findHelpFile;
"foobar".findHelpFile;
::


method::help

performs link::#-findHelpFile:: on this, and opens the file it if it exists, otherwise opens the main helpfile.

code::
"Document".help;
"foobar".help;
::


subsection:: Misc methods


method::inspectorClass

returns class link::Classes/StringInspector::.


subsection:: Drawing Support


The following methods must be called within an Window-drawFunc or a SCUserView-drawFunc function, and will only be visible once the window or the view is refreshed. Each call to Window-refresh SCUserView-refresh will 'overwrite' all previous drawing by executing the currently defined function.

See also: link::Classes/Window::, link::Classes/UserView::, link::Classes/Color::, and link::Classes/Pen::.

note::
for cross-platform GUIs, use code::Pen.stringAtPoint, Pen.stringInRect, Pen.stringCenteredIn, Pen.stringLeftJustIn, Pen.stringRightJustIn:: instead.
::


method::draw

draws the String at the current 0@0 link::Classes/Point::. If no transformations of the graphics state have taken place, this will be the upper left corner of the window. See also link::Classes/Pen::.

code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
	"abababababa\n\n\n".scramble.draw
};
w.refresh
)
::


method::drawAtPoint

draws the String at the given link::Classes/Point:: using the link::Classes/Font:: and link::Classes/Color:: specified.

code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawAtPoint(
		100@100,
		Font("Courier", 30),
		Color.blue(0.3, 0.5))
};
w.refresh;
)
::


method::drawInRect

draws the String into the given link::Classes/Rect:: using the link::Classes/Font:: and link::Classes/Color:: specified.

code::
(
w = Window.new.front;
r = Rect(100, 100, 100, 100);
w.view.background_(Color.white);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawInRect(r, Font("Courier", 12), Color.blue(0.3, 0.5));
	Pen.strokeRect(r);
};
w.refresh;
)
::


method::drawCenteredIn

draws the String into the given Rect using the Font and Color specified.

code::
(
w = Window.new.front;
w.view.background_(Color.white);
r = Rect(100, 100, 100, 100);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawCenteredIn(
		r,
		Font("Courier", 12),
		Color.blue(0.3, 0.5)
	);
	Pen.strokeRect(r);
};
w.refresh;
)
::


method::drawLeftJustIn

draws the String into the given Rect using the Font and Color specified.

code::
(
w = Window.new.front;
w.view.background_(Color.white);
r = Rect(100, 100, 100, 100);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawLeftJustIn(
		r,
		Font("Courier", 12),
		Color.blue(0.3, 0.5)
	);
	Pen.strokeRect(r);
};
w.refresh;
)
::


method::drawRightJustIn

draws the String into the given link::Classes/Rect:: using the link::Classes/Font:: and link::Classes/Color:: specified.

code::
(
w = Window.new.front;
w.view.background_(Color.white);
r = Rect(100, 100, 100, 100);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawRightJustIn(
		r,
		Font("Courier", 12),
		Color.blue(0.3, 0.5)
	);
	Pen.strokeRect(r);
};
w.refresh;
)
::


method::bounds

tries to return a link::Classes/Rect:: with the size needed to fit this string if drawn with given font.

argument::font
a link::Classes/Font::
