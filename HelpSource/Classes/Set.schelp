title:: Set
summary:: a set according to equality
categories:: Collections>Unordered
related:: Classes/IdentitySet, Classes/List, Classes/Dictionary


description::


A Set is s collection of objects, no two of which are equal. Most of its methods are inherited from Collection. The contents of a Set are unordered. You must not depend on the order of items in a set. For an ordered set, see link::Classes/OrderedIdentitySet::.


instancemethods::


private:: initSet, putCheck, fullCheck, grow, noCheckAdd


subsection:: Adding and Removing


method::add

adds an Object to the Set. An object which is equal to an object already in the Set will not be added.

code::
Set[1, 2, 3].add(4).postln;
Set[1, 2, 3].add(3).postln;
Set["abc", "def", "ghi"].add("jkl").postln;
Set["abc", "def", "ghi"].add("def").postln;
::


method::remove

removes an Object from the Set. Element is checked for equality (not for identity).

code::
Set[1, 2, 3].remove(3).postln;
::


subsection:: Testing


method::includes

returns code::true:: if the specified item is present in the Set. Elements are checked for equality (not for identity).

code::
Set[1, 2, 3].includes(2).postln;
::


method::findMatch

returns the item, if it is present in the set. Otherwise returns code::nil::. Element is checked for equality (not for identity).

code::
Set[1, 2, 3].findMatch(3).postln;
::


subsection:: Iteration


method::do

evaluates function for each item in the Set. The function is passed two arguments, the item and an integer index.

code::
Set[1, 2, 3, 300].do({ |item, i| item.postln });
::


method::keyAt

returns the object at the internal strong::index::. This index is not deterministic.


subsection:: Set specific operations


method::sect, &

returns the set theoretical intersection of this and strong::that::. The function will search for objects occurring in both sets and return a new set containing those.
Elements are checked for equality (not for identity).

code::
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
sect(a, b);
a & b // shorter syntax
::


method::union, |

returns the set theoretical union of this and strong::that::. The function combines the two sets into one without duplicates.
Elements are checked for equality (not for identity).

code::
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
union(a, b);
a | b // shorter syntax
::


method::difference, -

returns the set of all items which are elements of this, but not of strong::that::. Elements are checked for equality (not for identity).

code::
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
difference(a, b);
a - b // shorter syntax
::


method::symmetricDifference, --

returns the set of all items which are not elements of both this and strong::that::.
Elements are checked for equality (not for identity).

code::
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
symmetricDifference(a, b);
a -- b // shorter syntax
::


method::isSubsetOf

returns code::true:: if all elements of this are also elements of strong::that::. Elements are checked for equality (not for identity).
Since Set is an unordered collection, order doesn't matter in this comparison.

code::
a = Set[1, 2, 3, 4];
Set[1, 2].isSubsetOf(a); // true
Set[1, 5].isSubsetOf(a); // false
::


examples::

code::
a = Set[1, 2, 3, 4];
b = a.powerset; // set of all parts
a.isSubsetOf(b); // false: no set is ever part of itself.
b.asArray.reduce(\union) == a; // true parts may not contain other elements that original
b.asArray.reduce(\difference).isEmpty; // true.
::

code::
// you can use Set to efficiently remove duplicates from an array:

a = [1, 2, 3, 4, 3, 5, 5, 2, 2, 1];
a.as(Set);		// convert to set
a.as(Set).as(Array);	// and convert back
::
